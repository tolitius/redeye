<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>REDEYE</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a15;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      border-radius: 4px;
      box-shadow: 0 0 40px rgba(255, 0, 64, 0.15);
    }
  </style>
</head>
<body>
  <script src="https://unpkg.com/kaplay@3001/dist/kaplay.js"></script>
  <script>
    // ============================================
    // REDEYE - A Sidescroller Roguelike
    // Phase 1: Core Feel (with animated character)
    // ============================================

    // === NEON PALETTE (from design spec) ===
    const PALETTE = {
      bg: "#0f0f23",
      bgLight: "#1a1a3e",
      bgAccent: "#2a2a5e",
      body: "#1a1a2e",
      eyes: "#ff0040",
      aura: "#ff0040",
      blade: "#ff0040",
      bladeTrail: "#ff6680",
      enemy: "#cccccc",
      enemyFlicker: "#ffffff",
      health: "#4ade80",
      signalBoost: "#60a5fa",
      upgrade: "#fbbf24",
      text: "#ffffff",
      textDim: "#8080a0",
      healthFull: "#ff0040",
      healthEmpty: "#4a4a4a",
      signalBar: "#ff0040",
      signalEmpty: "#2a2a2a",
      platform: "#464666",
      platformDark: "#2a2a4a",
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [0, 0, 0]
    }

    // === GAME CONSTANTS ===
    const SPEED = 300
    const JUMP_FORCE = 550
    const GRAVITY_RISE = 1400
    const GRAVITY_FALL = 1800
    const MAX_FALL_SPEED = 600

    const DASH_DISTANCE = 128
    const DASH_DURATION = 0.15
    const DASH_SPEED = DASH_DISTANCE / DASH_DURATION

    const SIGNAL_MAX = 10
    const SIGNAL_REGEN_RIGHT = 1.5
    const SIGNAL_DRAIN_STILL = 0.5
    const SIGNAL_DRAIN_LEFT = 1.5
    const SLASH_COST = 1
    const DASH_COST = 1

    const SLASH_DURATION = 0.2
    const SLASH_RANGE = 48
    const SLASH_DAMAGE = 1

    const Z = {
      BG: -100,
      BG_PARTICLES: -50,
      PLATFORMS: 0,
      PICKUPS: 10,
      ENEMIES: 20,
      PLAYER_LEGS: 28,
      PLAYER: 30,
      PLAYER_ARM: 32,
      SLASH: 35,
      PARTICLES: 50,
      HUD: 100,
    }

    // ============================================
    // PROCEDURAL SPRITE GENERATORS
    // ============================================

    function makeGradientBg(w = 800, h = 600) {
      const c = document.createElement("canvas")
      c.width = w; c.height = h
      const ctx = c.getContext("2d")

      const grad = ctx.createLinearGradient(0, 0, 0, h)
      grad.addColorStop(0, PALETTE.bgLight)
      grad.addColorStop(0.5, PALETTE.bg)
      grad.addColorStop(1, "#0a0a15")
      ctx.fillStyle = grad
      ctx.fillRect(0, 0, w, h)

      for (let i = 0; i < 60; i++) {
        const x = Math.random() * w
        const y = Math.random() * h * 0.8
        const r = Math.random() * 1.5 + 0.5
        const isRed = Math.random() < 0.15
        ctx.fillStyle = isRed ? "rgba(255,0,64,0.3)" : `rgba(255,255,255,${0.1 + Math.random() * 0.15})`
        ctx.beginPath()
        ctx.arc(x, y, r, 0, Math.PI * 2)
        ctx.fill()
      }

      return c.toDataURL()
    }

    // redeye sprite - full cloaked figure with glowing eyes
    function makeRedeyeBodySprite(size = 64) {
      const c = document.createElement("canvas")
      c.width = size
      c.height = size
      const ctx = c.getContext("2d")

      const cx = size / 2
      const cy = size * 0.45

      // red aura glow
      const auraGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.55)
      auraGrad.addColorStop(0, "rgba(255,0,64,0.25)")
      auraGrad.addColorStop(0.5, "rgba(255,0,64,0.1)")
      auraGrad.addColorStop(1, "transparent")
      ctx.fillStyle = auraGrad
      ctx.fillRect(0, 0, c.width, c.height)

      // full cloak body - tall flowing robe (slimmer)
      const bodyGrad = ctx.createLinearGradient(cx - size*0.25, 0, cx + size*0.25, size)
      bodyGrad.addColorStop(0, "#2a2a3e")
      bodyGrad.addColorStop(0.3, PALETTE.body)
      bodyGrad.addColorStop(1, "#0a0a15")

      ctx.fillStyle = bodyGrad
      ctx.beginPath()
      ctx.moveTo(cx, size * 0.05)  // top of hood
      ctx.quadraticCurveTo(cx + size * 0.32, size * 0.1, cx + size * 0.36, size * 0.35)
      ctx.quadraticCurveTo(cx + size * 0.34, size * 0.6, cx + size * 0.28, size * 0.95)
      ctx.lineTo(cx - size * 0.28, size * 0.95)
      ctx.quadraticCurveTo(cx - size * 0.34, size * 0.6, cx - size * 0.36, size * 0.35)
      ctx.quadraticCurveTo(cx - size * 0.32, size * 0.1, cx, size * 0.05)
      ctx.closePath()
      ctx.fill()

      // cloak bottom tattered edge
      ctx.fillStyle = "#0a0a15"
      ctx.beginPath()
      ctx.moveTo(cx - size * 0.28, size * 0.95)
      ctx.lineTo(cx - size * 0.24, size * 0.88)
      ctx.lineTo(cx - size * 0.12, size * 0.95)
      ctx.lineTo(cx, size * 0.9)
      ctx.lineTo(cx + size * 0.12, size * 0.95)
      ctx.lineTo(cx + size * 0.24, size * 0.88)
      ctx.lineTo(cx + size * 0.28, size * 0.95)
      ctx.closePath()
      ctx.fill()

      // edge highlight
      ctx.strokeStyle = "rgba(255,255,255,0.1)"
      ctx.lineWidth = 1
      ctx.beginPath()
      ctx.moveTo(cx, size * 0.05)
      ctx.quadraticCurveTo(cx - size * 0.32, size * 0.1, cx - size * 0.36, size * 0.35)
      ctx.stroke()

      // glowing red eyes
      const eyeY = size * 0.28
      const eyeSpacing = size * 0.12
      const eyeSize = size * 0.055

      for (let i = 0; i < 2; i++) {
        const ex = cx + (i === 0 ? -eyeSpacing : eyeSpacing)
        const eyeGlow = ctx.createRadialGradient(ex, eyeY, 0, ex, eyeY, eyeSize * 4)
        eyeGlow.addColorStop(0, "rgba(255,0,64,0.9)")
        eyeGlow.addColorStop(0.3, "rgba(255,0,64,0.4)")
        eyeGlow.addColorStop(1, "transparent")
        ctx.fillStyle = eyeGlow
        ctx.fillRect(ex - eyeSize*5, eyeY - eyeSize*5, eyeSize*10, eyeSize*10)
      }

      ctx.fillStyle = "#ff0040"
      ctx.shadowColor = "#ff0040"
      ctx.shadowBlur = 12
      ctx.beginPath()
      ctx.arc(cx - eyeSpacing, eyeY, eyeSize, 0, Math.PI * 2)
      ctx.arc(cx + eyeSpacing, eyeY, eyeSize, 0, Math.PI * 2)
      ctx.fill()

      ctx.fillStyle = "#ff8080"
      ctx.shadowBlur = 6
      ctx.beginPath()
      ctx.arc(cx - eyeSpacing, eyeY, eyeSize * 0.4, 0, Math.PI * 2)
      ctx.arc(cx + eyeSpacing, eyeY, eyeSize * 0.4, 0, Math.PI * 2)
      ctx.fill()
      ctx.shadowBlur = 0

      return c.toDataURL()
    }

    // sword blade sprite - large glowing blade
    function makeSwordArmSprite(size = 70) {
      const c = document.createElement("canvas")
      c.width = size
      c.height = size * 0.25
      const ctx = c.getContext("2d")

      // outer glow
      ctx.shadowColor = "#ff0040"
      ctx.shadowBlur = 25

      // blade body - thick glowing line
      const bladeGrad = ctx.createLinearGradient(0, c.height/2, c.width, c.height/2)
      bladeGrad.addColorStop(0, "#ff0040")
      bladeGrad.addColorStop(0.6, "#ff4466")
      bladeGrad.addColorStop(1, "#ffffff")

      ctx.strokeStyle = bladeGrad
      ctx.lineWidth = c.height * 0.6
      ctx.lineCap = "round"
      ctx.beginPath()
      ctx.moveTo(8, c.height/2)
      ctx.lineTo(c.width - 4, c.height/2)
      ctx.stroke()

      // bright core
      ctx.shadowBlur = 15
      ctx.strokeStyle = "#ffcccc"
      ctx.lineWidth = c.height * 0.25
      ctx.beginPath()
      ctx.moveTo(10, c.height/2)
      ctx.lineTo(c.width - 6, c.height/2)
      ctx.stroke()

      ctx.shadowBlur = 0

      return c.toDataURL()
    }

    // slash arc effect
    function makeSlashArcSprite(size = 80) {
      const c = document.createElement("canvas")
      c.width = size * 1.2
      c.height = size
      const ctx = c.getContext("2d")

      const cx = size * 0.2
      const cy = size / 2

      // outer glow
      ctx.strokeStyle = "rgba(255,0,64,0.3)"
      ctx.lineWidth = 20
      ctx.lineCap = "round"
      ctx.beginPath()
      ctx.arc(cx, cy, size * 0.45, -Math.PI * 0.5, Math.PI * 0.5)
      ctx.stroke()

      // main arc
      ctx.strokeStyle = "#ff0040"
      ctx.lineWidth = 6
      ctx.shadowColor = "#ff0040"
      ctx.shadowBlur = 20
      ctx.beginPath()
      ctx.arc(cx, cy, size * 0.45, -Math.PI * 0.5, Math.PI * 0.5)
      ctx.stroke()

      // bright core
      ctx.strokeStyle = "#ff9999"
      ctx.lineWidth = 2
      ctx.shadowBlur = 10
      ctx.beginPath()
      ctx.arc(cx, cy, size * 0.45, -Math.PI * 0.45, Math.PI * 0.45)
      ctx.stroke()

      ctx.shadowBlur = 0

      return c.toDataURL()
    }

    function makePlatformSprite(w = 160, h = 24) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")
      const r = 4

      const grad = ctx.createLinearGradient(0, 0, 0, h)
      grad.addColorStop(0, PALETTE.platform)
      grad.addColorStop(1, PALETTE.platformDark)
      ctx.fillStyle = grad
      ctx.beginPath()
      ctx.roundRect(0, 0, w, h, r)
      ctx.fill()

      ctx.fillStyle = "rgba(255,255,255,0.08)"
      ctx.fillRect(r, 1, w - r*2, 2)

      ctx.strokeStyle = "rgba(255,0,64,0.15)"
      ctx.lineWidth = 1
      ctx.beginPath()
      ctx.roundRect(0.5, 0.5, w-1, h-1, r)
      ctx.stroke()

      return c.toDataURL()
    }

    function makeGroundSprite(w = 800, h = 48) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      const grad = ctx.createLinearGradient(0, 0, 0, h)
      grad.addColorStop(0, PALETTE.platform)
      grad.addColorStop(0.3, PALETTE.platformDark)
      grad.addColorStop(1, "#1a1a2a")
      ctx.fillStyle = grad
      ctx.fillRect(0, 0, w, h)

      ctx.fillStyle = "rgba(255,255,255,0.06)"
      ctx.fillRect(0, 0, w, 2)

      ctx.strokeStyle = "rgba(0,0,0,0.1)"
      for (let x = 40; x < w; x += 60) {
        ctx.beginPath()
        ctx.moveTo(x, 4)
        ctx.lineTo(x, h - 2)
        ctx.stroke()
      }

      return c.toDataURL()
    }

    // crawler enemy sprite - low wide rectangle with static effect
    function makeCrawlerSprite(w = 28, h = 20) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // base body - white/grey
      const bodyGrad = ctx.createLinearGradient(0, 0, 0, h)
      bodyGrad.addColorStop(0, "#dddddd")
      bodyGrad.addColorStop(0.5, "#aaaaaa")
      bodyGrad.addColorStop(1, "#888888")
      ctx.fillStyle = bodyGrad

      // rounded rectangle body
      ctx.beginPath()
      ctx.roundRect(2, 4, w - 4, h - 6, 4)
      ctx.fill()

      // static noise overlay
      ctx.fillStyle = "rgba(255,255,255,0.3)"
      for (let i = 0; i < 15; i++) {
        const nx = Math.random() * (w - 6) + 3
        const ny = Math.random() * (h - 8) + 5
        ctx.fillRect(nx, ny, 2, 2)
      }

      // dark spots (no eyes - key visual distinction)
      ctx.fillStyle = "rgba(0,0,0,0.2)"
      ctx.fillRect(6, 8, 4, 4)
      ctx.fillRect(w - 10, 8, 4, 4)

      // small legs
      ctx.fillStyle = "#666666"
      for (let i = 0; i < 4; i++) {
        const lx = 5 + i * 6
        ctx.fillRect(lx, h - 4, 2, 4)
      }

      return c.toDataURL()
    }

    // spitter enemy sprite - vertical blob with mouth
    function makeSpitterSprite(w = 24, h = 36) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // body - vertical blob shape
      const bodyGrad = ctx.createLinearGradient(0, 0, 0, h)
      bodyGrad.addColorStop(0, "#cccccc")
      bodyGrad.addColorStop(0.5, "#999999")
      bodyGrad.addColorStop(1, "#666666")
      ctx.fillStyle = bodyGrad

      // blob body
      ctx.beginPath()
      ctx.ellipse(w/2, h/2 + 4, w/2 - 2, h/2 - 2, 0, 0, Math.PI * 2)
      ctx.fill()

      // mouth opening (dark hole)
      ctx.fillStyle = "#222222"
      ctx.beginPath()
      ctx.ellipse(w/2, 10, 6, 4, 0, 0, Math.PI * 2)
      ctx.fill()

      // static noise
      ctx.fillStyle = "rgba(255,255,255,0.25)"
      for (let i = 0; i < 12; i++) {
        const nx = Math.random() * (w - 8) + 4
        const ny = Math.random() * (h - 10) + 8
        ctx.fillRect(nx, ny, 2, 2)
      }

      return c.toDataURL()
    }

    // spitter projectile sprite
    function makeProjectileSprite(size = 8) {
      const c = document.createElement("canvas")
      c.width = size
      c.height = size
      const ctx = c.getContext("2d")

      // white orb with glow
      ctx.shadowColor = "#ffffff"
      ctx.shadowBlur = 4
      ctx.fillStyle = "#ffffff"
      ctx.beginPath()
      ctx.arc(size/2, size/2, size/2 - 1, 0, Math.PI * 2)
      ctx.fill()

      // inner static
      ctx.fillStyle = "rgba(200,200,200,0.5)"
      ctx.fillRect(size/2 - 1, size/2 - 1, 2, 2)

      return c.toDataURL()
    }

    // rusher enemy sprite - wide, low, aggressive shape
    function makeRusherSprite(w = 40, h = 18) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // body gradient - slightly darker than crawler
      const bodyGrad = ctx.createLinearGradient(0, 0, 0, h)
      bodyGrad.addColorStop(0, "#bbbbbb")
      bodyGrad.addColorStop(0.5, "#888888")
      bodyGrad.addColorStop(1, "#555555")
      ctx.fillStyle = bodyGrad

      // wedge/arrow shape pointing right
      ctx.beginPath()
      ctx.moveTo(w - 4, h / 2)        // point
      ctx.lineTo(4, 2)                 // top back
      ctx.lineTo(4, h - 2)             // bottom back
      ctx.closePath()
      ctx.fill()

      // speed lines on back
      ctx.strokeStyle = "rgba(255,255,255,0.3)"
      ctx.lineWidth = 1
      for (let i = 0; i < 3; i++) {
        const y = 5 + i * 4
        ctx.beginPath()
        ctx.moveTo(2, y)
        ctx.lineTo(10, y)
        ctx.stroke()
      }

      // static noise
      ctx.fillStyle = "rgba(255,255,255,0.2)"
      for (let i = 0; i < 8; i++) {
        const nx = 8 + Math.random() * (w - 16)
        const ny = 4 + Math.random() * (h - 8)
        ctx.fillRect(nx, ny, 2, 2)
      }

      return c.toDataURL()
    }

    function makeDrifterSprite(r = 16) {
      const size = r * 2 + 4
      const c = document.createElement("canvas")
      c.width = size
      c.height = size
      const ctx = c.getContext("2d")
      const cx = size / 2
      const cy = size / 2

      // outer glow
      const glowGrad = ctx.createRadialGradient(cx, cy, r * 0.3, cx, cy, r)
      glowGrad.addColorStop(0, "rgba(200, 180, 255, 0.9)")
      glowGrad.addColorStop(0.5, "rgba(150, 120, 200, 0.5)")
      glowGrad.addColorStop(1, "rgba(100, 80, 150, 0)")
      ctx.fillStyle = glowGrad
      ctx.beginPath()
      ctx.arc(cx, cy, r, 0, Math.PI * 2)
      ctx.fill()

      // core
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)"
      ctx.beginPath()
      ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2)
      ctx.fill()

      // static specks
      ctx.fillStyle = "rgba(255,255,255,0.4)"
      for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2
        const dist = r * 0.4 + Math.random() * r * 0.4
        ctx.fillRect(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, 2, 2)
      }

      return c.toDataURL()
    }

    function makePillarSprite(w = 24, h = 48) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // body gradient - dark metallic
      const bodyGrad = ctx.createLinearGradient(0, 0, w, 0)
      bodyGrad.addColorStop(0, "#444444")
      bodyGrad.addColorStop(0.3, "#666666")
      bodyGrad.addColorStop(0.7, "#555555")
      bodyGrad.addColorStop(1, "#333333")
      ctx.fillStyle = bodyGrad
      ctx.fillRect(2, 4, w - 4, h - 4)

      // top cap
      ctx.fillStyle = "#777777"
      ctx.fillRect(0, 0, w, 6)

      // horizontal bands
      ctx.fillStyle = "#555555"
      ctx.fillRect(0, h * 0.33, w, 3)
      ctx.fillRect(0, h * 0.66, w, 3)

      // static glitch lines
      ctx.fillStyle = "rgba(255,255,255,0.3)"
      for (let i = 0; i < 6; i++) {
        const y = 8 + Math.random() * (h - 16)
        const lw = 4 + Math.random() * 8
        ctx.fillRect(4 + Math.random() * (w - 12), y, lw, 2)
      }

      return c.toDataURL()
    }

    // static death particles for enemies
    function spawnStaticBurst(p) {
      for (let i = 0; i < 15; i++) {
        add([
          rect(rand(3, 8), rand(3, 8)),
          pos(p.x + rand(-10, 10), p.y + rand(-10, 10)),
          color(rand(180, 255), rand(180, 255), rand(180, 255)),
          opacity(1),
          move(rand(0, 360), rand(80, 200)),
          lifespan(rand(0.2, 0.5), { fade: 0.15 }),
          rotate(rand(0, 360)),
          z(Z.PARTICLES),
        ])
      }
    }

    // health drop from enemies (called from game scene)
    const HEALTH_DROP_CHANCE = 0.25  // 25% chance

    // ============================================
    // EFFECT HELPERS
    // ============================================

    function spawnAuraParticle(p) {
      add([
        circle(rand(2, 4)),
        pos(p.x + rand(-8, 8), p.y + rand(-5, 15)),
        color(255, 0, 64),
        opacity(rand(0.3, 0.6)),
        move(90, rand(20, 50)),
        lifespan(rand(0.3, 0.6), { fade: 0.2 }),
        scale(1),
        z(Z.PARTICLES - 5),
      ])
    }

    function slashBurst(p, facing) {
      const baseAngle = facing > 0 ? 0 : 180
      for (let i = 0; i < 12; i++) {
        add([
          circle(rand(2, 6)),
          pos(p.x + facing * 30, p.y),
          color(255, rand(0, 100), rand(64, 128)),
          opacity(1),
          move(baseAngle + rand(-60, 60), rand(100, 250)),
          lifespan(0.3, { fade: 0.2 }),
          scale(1),
          z(Z.PARTICLES),
        ])
      }
    }

    function spawnAfterimage(obj) {
      const img = add([
        sprite("redeye"),
        pos(obj.pos.x, obj.pos.y),
        anchor("bot"),
        scale(obj.scale.x, obj.scale.y),
        opacity(0.4),
        z(Z.PLAYER - 1),
      ])
      img.onUpdate(() => {
        img.opacity -= dt() * 3
        if (img.opacity <= 0) destroy(img)
      })
    }

    function spawnAmbientParticle() {
      const isRed = Math.random() < 0.2
      add([
        circle(rand(0.5, 2)),
        pos(rand(0, width()), height() + 10),
        color(isRed ? 255 : 200, isRed ? 0 : 200, isRed ? 64 : 220),
        opacity(rand(0.05, 0.15)),
        move(rand(80, 100), rand(10, 30)),
        lifespan(rand(6, 12), { fade: 3 }),
        scale(1),
        z(Z.BG_PARTICLES),
      ])
    }

    function floatingText(p, txt, col) {
      const ft = add([
        text(txt, { size: 16 }),
        pos(p.x, p.y - 10),
        anchor("center"),
        color(col[0], col[1], col[2]),
        opacity(1),
        z(Z.PARTICLES + 10),
      ])
      ft.onUpdate(() => {
        ft.pos.y -= 50 * dt()
        ft.opacity -= 1.2 * dt()
        if (ft.opacity <= 0) destroy(ft)
      })
    }

    // ============================================
    // GAME INITIALIZATION
    // ============================================
    kaplay({
      width: 800,
      height: 600,
      background: hexToRgb(PALETTE.bg),
      scale: 1,
      debug: true,
      focus: true,  // auto-focus canvas on load
    })

    // === PERSISTENT SAVE SYSTEM ===
    const SAVE_KEY = "redeye_save"
    const OLD_HIGHSCORE_KEY = "redeye_highscore"
    const OLD_RUNCOUNT_KEY = "redeye_runcount"

    // echo earned by depth bracket
    const ECHO_BY_DEPTH = [
      0,                      // depth 0 (unused)
      1, 1, 1, 1,             // depth 1-4: 1 echo
      3, 3, 3, 3, 3,          // depth 5-9: 3 echo
      6, 6, 6, 6, 6,          // depth 10-14: 6 echo
      10, 10, 10, 10, 10,     // depth 15-19: 10 echo
      15                      // depth 20: 15 echo (victory)
    ]

    // unlock definitions
    const UNLOCKS = {
      // abilities (future phases)
      push: { cost: 8, type: 'ability', name: 'Push', desc: 'Unlocks Push ability' },
      pull: { cost: 12, type: 'ability', name: 'Pull', desc: 'Unlocks Pull ability' },
      doubleJump: { cost: 15, type: 'ability', name: 'Double Jump', desc: 'Jump again mid-air' },
      wallSlide: { cost: 10, type: 'ability', name: 'Wall Slide', desc: 'Slide down walls' },
      airDash: { cost: 20, type: 'ability', name: 'Air Dash', desc: 'Dash in any direction mid-air' },

      // starting bonuses
      vitality1: { cost: 5, type: 'bonus', name: 'Vitality I', desc: '+1 starting health', stat: 'health', value: 1 },
      vitality2: { cost: 10, type: 'bonus', name: 'Vitality II', desc: '+1 starting health', stat: 'health', value: 1, requires: 'vitality1' },
      vitality3: { cost: 15, type: 'bonus', name: 'Vitality III', desc: '+1 starting health', stat: 'health', value: 1, requires: 'vitality2' },

      attunement1: { cost: 5, type: 'bonus', name: 'Attunement I', desc: '+2 starting signal', stat: 'signal', value: 2 },
      attunement2: { cost: 10, type: 'bonus', name: 'Attunement II', desc: '+2 starting signal', stat: 'signal', value: 2, requires: 'attunement1' },
      attunement3: { cost: 15, type: 'bonus', name: 'Attunement III', desc: '+2 starting signal', stat: 'signal', value: 2, requires: 'attunement2' },

      // quality of life
      signalSight: { cost: 10, type: 'qol', name: 'Signal Sight', desc: 'See enemy health bars' },
      momentum: { cost: 15, type: 'qol', name: 'Momentum', desc: 'Standing still drains 50% less signal' },
      lastStand: { cost: 20, type: 'qol', name: 'Last Stand', desc: 'Once per run, survive lethal hit with 1 HP' },
    }

    // default save structure
    function getDefaultSave() {
      return {
        echo: 0,
        totalRuns: 0,
        bestDepth: 0,
        unlocks: [],
        stats: { bonusHealth: 0, bonusSignal: 0, bonusDamage: 0, bonusRegen: 0 }
      }
    }

    // load save data (with migration from old format)
    function loadSave() {
      try {
        const saved = localStorage.getItem(SAVE_KEY)
        if (saved) {
          return { ...getDefaultSave(), ...JSON.parse(saved) }
        }

        // migrate from old format if exists
        const oldHighscore = parseInt(localStorage.getItem(OLD_HIGHSCORE_KEY)) || 0
        const oldRuncount = parseInt(localStorage.getItem(OLD_RUNCOUNT_KEY)) || 0

        if (oldHighscore > 0 || oldRuncount > 0) {
          const migrated = getDefaultSave()
          migrated.bestDepth = oldHighscore
          migrated.totalRuns = oldRuncount
          // give some echo based on previous play
          migrated.echo = Math.floor(oldRuncount * 2)
          saveSave(migrated)
          // clean up old keys
          localStorage.removeItem(OLD_HIGHSCORE_KEY)
          localStorage.removeItem(OLD_RUNCOUNT_KEY)
          return migrated
        }

        return getDefaultSave()
      } catch (e) {
        return getDefaultSave()
      }
    }

    function saveSave(data) {
      try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(data))
      } catch (e) {
        // silently fail
      }
    }

    // global save data
    let saveData = loadSave()

    // helper functions
    function getHighScore() {
      return saveData.bestDepth
    }

    function hasUnlock(id) {
      return saveData.unlocks.includes(id)
    }

    function canPurchase(id) {
      const unlock = UNLOCKS[id]
      if (!unlock) return false
      if (hasUnlock(id)) return false
      if (saveData.echo < unlock.cost) return false
      if (unlock.requires && !hasUnlock(unlock.requires)) return false
      return true
    }

    function purchaseUnlock(id) {
      if (!canPurchase(id)) return false
      const unlock = UNLOCKS[id]
      saveData.echo -= unlock.cost
      saveData.unlocks.push(id)
      saveSave(saveData)
      return true
    }

    // check if any owned upgrade requires this one
    function hasDependentUnlock(id) {
      for (const [otherId, unlock] of Object.entries(UNLOCKS)) {
        if (unlock.requires === id && hasUnlock(otherId)) {
          return otherId
        }
      }
      return null
    }

    function sellUnlock(id) {
      if (!hasUnlock(id)) return false
      const dependent = hasDependentUnlock(id)
      if (dependent) return false
      const unlock = UNLOCKS[id]
      saveData.echo += unlock.cost
      saveData.unlocks = saveData.unlocks.filter(u => u !== id)
      saveSave(saveData)
      return true
    }

    // calculate echo earned on death
    function calculateEchoEarned(depth, isNewBest) {
      let earned = ECHO_BY_DEPTH[Math.min(depth, 20)] || 1
      let breakdown = { base: earned, newBest: 0, total: earned }

      if (isNewBest && depth > 0) {
        breakdown.newBest = 2
        breakdown.total += 2
      }

      return breakdown
    }

    // called on death
    function onRunEnd(depth) {
      const isNewBest = depth > saveData.bestDepth
      const echoBreakdown = calculateEchoEarned(depth, isNewBest)

      saveData.echo += echoBreakdown.total
      saveData.totalRuns += 1
      if (isNewBest) {
        saveData.bestDepth = depth
      }

      saveSave(saveData)
      return { isNewBest, echoBreakdown }
    }

    // get starting stats with unlocks applied
    function getStartingStats() {
      const stats = {
        health: 5,
        signal: SIGNAL_MAX,
        damage: SLASH_DAMAGE,
        signalRegen: 1.0,  // multiplier
        abilities: []
      }

      // apply vitality bonuses
      if (hasUnlock('vitality1')) stats.health += 1
      if (hasUnlock('vitality2')) stats.health += 1
      if (hasUnlock('vitality3')) stats.health += 1

      // apply attunement bonuses
      if (hasUnlock('attunement1')) stats.signal += 2
      if (hasUnlock('attunement2')) stats.signal += 2
      if (hasUnlock('attunement3')) stats.signal += 2

      // apply fever dream stat bonuses (phase 2)
      stats.health += saveData.stats.bonusHealth || 0
      stats.signal += saveData.stats.bonusSignal || 0
      stats.damage += saveData.stats.bonusDamage || 0
      stats.signalRegen += saveData.stats.bonusRegen || 0

      return stats
    }

    function shouldShowIntro() {
      // show on first run or every 5th run
      return saveData.totalRuns === 0 || saveData.totalRuns % 5 === 0
    }

    // === FEVER DREAM SYSTEM (Phase 2) ===

    // check if fever dream triggers on death
    function checkFeverDream() {
      const deathCount = saveData.totalRuns
      const roll = Math.random()

      // early deaths: higher stat echo chance
      if (deathCount <= 5) {
        if (roll < 0.6) return 'statEcho'
        return null
      }

      // mid game: stat echo + memory surge (phase 3)
      if (deathCount <= 15) {
        if (roll < 0.5) return 'statEcho'
        // if (roll < 0.7) return 'memorySurge'  // phase 3
        return null
      }

      // later: all types available
      if (deathCount <= 30) {
        if (roll < 0.4) return 'statEcho'
        // if (roll < 0.65) return 'memorySurge'  // phase 3
        // if (roll < 0.8) return 'resonance'     // phase 3
        return null
      }

      // veteran: includes interference (phase 4)
      if (roll < 0.3) return 'statEcho'
      // if (roll < 0.5) return 'memorySurge'   // phase 3
      // if (roll < 0.65) return 'resonance'    // phase 3
      // if (roll < 0.8) return 'interference'  // phase 4
      return null
    }

    // stat echo options with weights
    const STAT_ECHOES = [
      { key: 'bonusHealth', amount: 0.5, text: '+0.5 Max Health', weight: 0.25 },
      { key: 'bonusSignal', amount: 0.5, text: '+0.5 Max Signal', weight: 0.30 },
      { key: 'bonusDamage', amount: 0.05, text: '+0.05 Blade Damage', weight: 0.20 },
      { key: 'bonusRegen', amount: 0.05, text: '+0.05 Signal Regen', weight: 0.25 },
    ]

    function weightedRandom(items) {
      const totalWeight = items.reduce((sum, item) => sum + item.weight, 0)
      let random = Math.random() * totalWeight
      for (const item of items) {
        random -= item.weight
        if (random <= 0) return item
      }
      return items[items.length - 1]
    }

    // apply stat echo and return the text to display
    function applyStatEcho() {
      const selected = weightedRandom(STAT_ECHOES)
      saveData.stats[selected.key] = (saveData.stats[selected.key] || 0) + selected.amount
      saveSave(saveData)
      return selected.text
    }

    // load sprites
    loadSprite("bg", makeGradientBg())
    loadSprite("redeye", makeRedeyeBodySprite(64))
    loadSprite("sword-arm", makeSwordArmSprite(50))
    loadSprite("slash-arc", makeSlashArcSprite(80))
    loadSprite("platform-sm", makePlatformSprite(100, 20))
    loadSprite("platform-md", makePlatformSprite(160, 24))
    loadSprite("platform-lg", makePlatformSprite(240, 24))
    loadSprite("ground", makeGroundSprite(800, 48))
    loadSprite("crawler", makeCrawlerSprite(28, 20))
    loadSprite("spitter", makeSpitterSprite(24, 36))
    loadSprite("projectile", makeProjectileSprite(8))
    loadSprite("rusher", makeRusherSprite(40, 18))
    loadSprite("drifter", makeDrifterSprite(16))
    loadSprite("pillar", makePillarSprite(24, 48))

    // ============================================
    // INTRO SCENE
    // ============================================
    scene("intro", () => {
      const isFirstRun = saveData.totalRuns === 0
      const skipDelay = isFirstRun ? 1.5 : 0
      let canSkip = !isFirstRun
      let skipped = false

      // black background
      add([rect(width(), height()), pos(0, 0), color(0, 0, 0), z(0)])

      // === STARS ===
      const stars = []
      for (let i = 0; i < 40; i++) {
        const star = add([
          circle(rand(1, 2.5)),
          pos(rand(50, width() - 50), rand(50, height() - 50)),
          color(255, 255, 255),
          opacity(rand(0.3, 0.7)),
          anchor("center"),
          z(1),
        ])
        stars.push(star)
      }

      // === COSMIC THREADS (between stars) ===
      const cosmicThreads = []
      for (let i = 0; i < 12; i++) {
        const star1 = stars[Math.floor(rand(0, stars.length))]
        const star2 = stars[Math.floor(rand(0, stars.length))]
        if (star1 === star2) continue

        const dx = star2.pos.x - star1.pos.x
        const dy = star2.pos.y - star1.pos.y
        const len = Math.sqrt(dx * dx + dy * dy)
        const angle = Math.atan2(dy, dx) * (180 / Math.PI)

        const thread = add([
          rect(len, 1),
          pos(star1.pos.x, star1.pos.y),
          color(255, 0, 64),
          opacity(0),
          anchor("left"),
          rotate(angle),
          z(2),
        ])
        cosmicThreads.push(thread)
      }

      // === SILHOUETTE (head shape) ===
      const silhouette = add([
        circle(45),
        pos(center().x, center().y + 10),
        color(20, 20, 25),
        opacity(0),
        anchor("center"),
        z(5),
      ])

      // === REDEYE'S EYES ===
      const eye1 = add([
        circle(8),
        pos(center().x - 18, center().y),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(10),
      ])
      const eye2 = add([
        circle(8),
        pos(center().x + 18, center().y),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(10),
      ])

      // === EYE GLOW (pulse ring) ===
      const eyeGlow1 = add([
        circle(12),
        pos(eye1.pos),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(9),
      ])
      const eyeGlow2 = add([
        circle(12),
        pos(eye2.pos),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(9),
      ])

      // === SISTER (starts next to redeye, drifts away) ===
      const redeyeCenter = vec2(center().x, center().y + 10)
      const sisterStartPos = vec2(center().x + 100, center().y + 10)  // starts beside redeye
      const sisterEndPos = vec2(width() - 120, 100)  // drifts to distant position
      let sisterCurrentPos = sisterStartPos.clone()

      // sister silhouette (smaller than redeye)
      const sisterSilhouette = add([
        circle(35),
        pos(sisterStartPos),
        color(20, 20, 25),
        opacity(0),
        anchor("center"),
        z(5),
      ])

      // sister's eyes
      const sisterEye1 = add([
        circle(6),
        pos(sisterStartPos.x - 12, sisterStartPos.y),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(10),
      ])
      const sisterEye2 = add([
        circle(6),
        pos(sisterStartPos.x + 12, sisterStartPos.y),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(10),
      ])

      // === GLOW AT FACE EDGES (where wave touches both faces) ===
      const faceGlow = add([
        circle(8),
        pos(0, 0),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(9),
      ])
      const sisterFaceGlow = add([
        circle(6),
        pos(0, 0),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(9),
      ])

      // === FLOWING WAVE CONNECTION ===
      const wavePoints = []
      const wavePointCount = 30
      const silhouetteRadius = 45  // redeye's face radius
      let sisterRadius = 35  // sister's radius (shrinks as she drifts)
      let waveActive = false
      let waveProgress = 0

      // create wave points
      for (let i = 0; i < wavePointCount; i++) {
        const t = i / (wavePointCount - 1)
        const wavePoint = add([
          circle(3),
          pos(0, 0),
          color(255, 0, 64),
          opacity(0),
          anchor("center"),
          z(8),
        ])
        wavePoints.push({ obj: wavePoint, t: t })
      }

      // wave animation - dynamically tracks sister position
      onUpdate(() => {
        if (!waveActive || skipped) return

        // calculate direction to sister's current position
        const toSister = sisterCurrentPos.sub(redeyeCenter)
        const connectionLen = toSister.len()
        if (connectionLen < 1) return

        // direction vector
        const dirX = toSister.x / connectionLen
        const dirY = toSister.y / connectionLen

        // wave starts at edge of redeye's face
        const edgeStart = vec2(
          redeyeCenter.x + dirX * silhouetteRadius,
          redeyeCenter.y + dirY * silhouetteRadius
        )

        // wave ends at edge of sister's face (facing redeye)
        const edgeEnd = vec2(
          sisterCurrentPos.x - dirX * sisterRadius,
          sisterCurrentPos.y - dirY * sisterRadius
        )

        // update both face glow positions
        faceGlow.pos.x = edgeStart.x
        faceGlow.pos.y = edgeStart.y
        sisterFaceGlow.pos.x = edgeEnd.x
        sisterFaceGlow.pos.y = edgeEnd.y

        const t = time()
        const waveLen = edgeEnd.sub(edgeStart).len()  // wave spans between edges

        wavePoints.forEach((wp, i) => {
          if (wp.t > waveProgress) {
            wp.obj.opacity = 0
            return
          }

          // position along line from redeye edge to sister edge
          const baseX = edgeStart.x + (edgeEnd.x - edgeStart.x) * wp.t
          const baseY = edgeStart.y + (edgeEnd.y - edgeStart.y) * wp.t

          // perpendicular offset for sine wave
          const perpX = -dirY
          const perpY = dirX
          const waveOffset = Math.sin(wp.t * 12 - t * 4) * 12

          wp.obj.pos.x = baseX + perpX * waveOffset
          wp.obj.pos.y = baseY + perpY * waveOffset

          // shimmer effect
          const shimmer = 0.5 + Math.sin(wp.t * 8 - t * 6) * 0.3
          wp.obj.opacity = shimmer

          // size pulse
          const sizePulse = 1 + Math.sin(wp.t * 10 - t * 5) * 0.3
          wp.obj.radius = 3 * sizePulse
        })

        // both face glows pulse gently
        const glowPulse = 0.4 + Math.sin(t * 3) * 0.2
        faceGlow.opacity = glowPulse
        faceGlow.radius = 8 + Math.sin(t * 5) * 3
        sisterFaceGlow.opacity = glowPulse
        sisterFaceGlow.radius = 6 + Math.sin(t * 5) * 2
      })

      // === SKIP HINT ===
      const skipHint = add([
        text("Press any key", { size: 14 }),
        pos(center().x, height() - 40),
        anchor("center"),
        color(255, 255, 255),
        opacity(0),
        z(50),
      ])

      // === NARRATIVE TEXT ===
      const narrativeLines = [
        "The universe speaks in red waves...",
        "Most are blind to it",
        "You're not. You are one with them",
        "Your sister saw deeper...",
        "They took her",
        "..Static..",
      ]

      const narrativeTexts = narrativeLines.map((line, i) => {
        return add([
          text(line, { size: 18 }),
          pos(center().x, height() - 80),
          anchor("center"),
          color(255, 60, 80),
          opacity(0),
          z(60),
        ])
      })

      // === TV STATIC EFFECT ===
      const staticLines = []
      const staticLineCount = 80
      for (let i = 0; i < staticLineCount; i++) {
        const line = add([
          rect(width(), rand(2, 6)),
          pos(0, i * (height() / staticLineCount)),
          color(255, 255, 255),
          opacity(0),
          z(200),
        ])
        staticLines.push(line)
      }

      let staticActive = false
      onUpdate(() => {
        if (!staticActive || skipped) return
        staticLines.forEach(line => {
          line.opacity = rand(0.1, 0.4)
          line.pos.y = rand(0, height())
          line.height = rand(1, 8)
          line.color = rgb(rand(180, 255), rand(180, 255), rand(180, 255))
        })
      })

      // ========== TIMELINE ==========

      // helper: show narrative text (fade in, hold, fade out)
      function showNarrative(index, fadeOutPrev = true) {
        if (skipped) return
        // fade out previous
        if (fadeOutPrev && index > 0) {
          tween(narrativeTexts[index - 1].opacity, 0, 0.4, (v) => narrativeTexts[index - 1].opacity = v)
        }
        // fade in current
        tween(0, 0.9, 0.5, (v) => narrativeTexts[index].opacity = v)
      }

      // [0.5s] "The universe speaks in red waves..." + Cosmic threads
      wait(0.5, () => {
        if (skipped) return
        showNarrative(0, false)
        cosmicThreads.forEach((t, i) => {
          wait(i * 0.05, () => {
            if (skipped) return
            tween(0, 0.15, 0.5, (v) => t.opacity = v)
          })
        })
      })

      // [4.0s] "Most are blind to it" + Silhouettes fade in
      wait(4.0, () => {
        if (skipped) return
        showNarrative(1)
        tween(0, 1, 0.4, (v) => silhouette.opacity = v)
        tween(0, 1, 0.4, (v) => sisterSilhouette.opacity = v)
      })

      // [7.5s] "You're not. You are one with them" + Eyes ignite
      wait(7.5, () => {
        if (skipped) return
        showNarrative(2)
        canSkip = true
        tween(skipHint.opacity, 0.3, 0.5, (v) => skipHint.opacity = v)

        // both pairs of eyes flash on
        eye1.opacity = 1
        eye2.opacity = 1
        sisterEye1.opacity = 1
        sisterEye2.opacity = 1

        // redeye glow pulse
        eyeGlow1.opacity = 0.8
        eyeGlow2.opacity = 0.8
        tween(12, 60, 0.6, (v) => { eyeGlow1.radius = v; eyeGlow2.radius = v }, easings.easeOutQuad)
        tween(0.8, 0, 0.6, (v) => { eyeGlow1.opacity = v; eyeGlow2.opacity = v })

        // cosmic threads brighten
        cosmicThreads.forEach(t => {
          tween(t.opacity, 0.4, 0.5, (v) => t.opacity = v)
        })
      })

      // [11.0s] "Your sister saw deeper..." + Wave forms
      wait(11.0, () => {
        if (skipped) return
        showNarrative(3)
        waveActive = true
        waveProgress = 1
      })

      // [14.0s] "They took her" + Sister drifts away
      wait(14.0, () => {
        if (skipped) return
        showNarrative(4)

        // sister drifts away over 2.5 seconds
        const driftDuration = 2.5
        tween(sisterStartPos.x, sisterEndPos.x, driftDuration, (v) => {
          if (skipped) return
          sisterCurrentPos.x = v
          sisterSilhouette.pos.x = v
          sisterEye1.pos.x = v - 12
          sisterEye2.pos.x = v + 12
        }, easings.easeInOutQuad)
        tween(sisterStartPos.y, sisterEndPos.y, driftDuration, (v) => {
          if (skipped) return
          sisterCurrentPos.y = v
          sisterSilhouette.pos.y = v
          sisterEye1.pos.y = v
          sisterEye2.pos.y = v
        }, easings.easeInOutQuad)

        // sister silhouette shrinks
        tween(35, 20, driftDuration, (v) => {
          if (skipped) return
          sisterSilhouette.radius = v
          sisterRadius = v
        }, easings.easeInOutQuad)
        tween(6, 4, driftDuration, (v) => {
          if (skipped) return
          sisterEye1.radius = v
          sisterEye2.radius = v
        }, easings.easeInOutQuad)
        tween(12, 8, driftDuration, (v) => {
          if (skipped) return
          sisterEye1.pos.x = sisterCurrentPos.x - v
          sisterEye2.pos.x = sisterCurrentPos.x + v
        }, easings.easeInOutQuad)
      })

      // [17.0s] "..Static.." + TV static effect
      wait(17.0, () => {
        if (skipped) return
        showNarrative(5)
        staticActive = true
      })

      // [19.0s] Static fades, everything else fades
      wait(19.0, () => {
        if (skipped) return
        staticActive = false
        waveActive = false

        // fade out static
        staticLines.forEach(line => {
          tween(line.opacity, 0, 0.5, (v) => line.opacity = v)
        })

        // fade out last narrative text
        tween(narrativeTexts[5].opacity, 0, 0.5, (v) => narrativeTexts[5].opacity = v)

        // fade everything else
        cosmicThreads.forEach(t => {
          tween(t.opacity, 0, 0.5, (v) => t.opacity = v)
        })
        wavePoints.forEach(wp => {
          tween(wp.obj.opacity, 0, 0.5, (v) => wp.obj.opacity = v)
        })
        tween(silhouette.opacity, 0, 0.5, (v) => silhouette.opacity = v)
        tween(sisterSilhouette.opacity, 0, 0.5, (v) => sisterSilhouette.opacity = v)
        tween(sisterEye1.opacity, 0, 0.5, (v) => sisterEye1.opacity = v)
        tween(sisterEye2.opacity, 0, 0.5, (v) => sisterEye2.opacity = v)
        tween(eye1.opacity, 0, 0.5, (v) => eye1.opacity = v)
        tween(eye2.opacity, 0, 0.5, (v) => eye2.opacity = v)
        tween(faceGlow.opacity, 0, 0.5, (v) => faceGlow.opacity = v)
        tween(sisterFaceGlow.opacity, 0, 0.5, (v) => sisterFaceGlow.opacity = v)
      })

      // [20.0s] Fade to menu
      wait(20.0, () => {
        if (skipped) return
        goToMenu()
      })

      function goToMenu() {
        if (skipped) return
        skipped = true
        const fade = add([
          rect(width(), height()),
          pos(0, 0),
          color(0, 0, 0),
          opacity(0),
          z(100),
        ])
        tween(fade.opacity, 1, 0.2, (v) => fade.opacity = v).then(() => {
          go("menu")
        })
      }

      // skip on any key
      onKeyPress(() => {
        if (canSkip && !skipped) goToMenu()
      })
      onClick(() => {
        if (canSkip && !skipped) goToMenu()
      })
    })

    // ============================================
    // MENU SCENE
    // ============================================
    scene("menu", () => {
      add([sprite("bg"), pos(0, 0), z(Z.BG)])
      loop(0.3, spawnAmbientParticle)

      // echo display (top left)
      add([
        text(`Echo: ${saveData.echo}`, { size: 18 }),
        pos(24, 24),
        color(hexToRgb(PALETTE.upgrade)),
        fixed(),
      ])

      add([
        text("REDEYE", { size: 64 }),
        pos(center().x, 120),
        anchor("center"),
        color(255, 0, 64),
      ])

      add([
        text("She's still out there.", { size: 18 }),
        pos(center().x, 240),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])
      add([
        text("Follow the signal.", { size: 18 }),
        pos(center().x, 270),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      add([
        text("SPACE - Begin", { size: 24 }),
        pos(center().x, 360),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])

      // only show upgrades if player has echo
      if (saveData.echo > 0) {
        add([
          text("U - Upgrades", { size: 20 }),
          pos(center().x, 400),
          anchor("center"),
          color(hexToRgb(PALETTE.upgrade)),
        ])
      }

      add([
        text("Arrow keys: Move | Space: Jump | Shift: Dash | X: Slash", { size: 14 }),
        pos(center().x, 480),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      // show stats
      const best = getHighScore()
      add([
        text(`Best Depth: ${best} | Runs: ${saveData.totalRuns}`, { size: 14 }),
        pos(center().x, 520),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      const sig = add([
        circle(6),
        pos(width() - 40, 40),
        color(255, 0, 64),
        opacity(1),
        anchor("center"),
      ])
      sig.onUpdate(() => {
        sig.opacity = 0.5 + Math.sin(time() * 2) * 0.5
        sig.scale = vec2(1 + Math.sin(time() * 2) * 0.2)
      })

      onKeyPress("space", () => go("game"))
      // only allow upgrades if player has echo
      if (saveData.echo > 0) {
        onKeyPress("u", () => go("upgrades"))
      }

      // reset save data (hold backspace for 2 seconds)
      let resetHoldTime = 0
      let resetWarning = null

      onKeyDown("backspace", () => {
        resetHoldTime += dt()

        if (resetHoldTime > 0.5 && !resetWarning) {
          resetWarning = add([
            text("Hold to reset all progress...", { size: 14 }),
            pos(center().x, height() - 60),
            anchor("center"),
            color(255, 100, 100),
          ])
        }

        if (resetHoldTime > 2) {
          // reset save data
          localStorage.removeItem(SAVE_KEY)
          saveData = getDefaultSave()
          go("menu")  // reload menu with fresh data
        }
      })

      onKeyRelease("backspace", () => {
        resetHoldTime = 0
        if (resetWarning) {
          destroy(resetWarning)
          resetWarning = null
        }
      })

      // hint for reset
      add([
        text("Hold BACKSPACE to reset progress", { size: 10 }),
        pos(center().x, height() - 15),
        anchor("center"),
        color(80, 80, 100),
      ])
    })

    // ============================================
    // UPGRADES SCENE
    // ============================================
    scene("upgrades", () => {
      add([sprite("bg"), pos(0, 0), z(Z.BG)])

      // echo display
      const echoLabel = add([
        text(`Echo: ${saveData.echo}`, { size: 24 }),
        pos(center().x, 30),
        anchor("center"),
        color(hexToRgb(PALETTE.upgrade)),
      ])

      add([
        text("UPGRADES", { size: 36 }),
        pos(center().x, 70),
        anchor("center"),
        color(255, 0, 64),
      ])

      // upgrade items to display
      const upgradeRows = [
        { section: "STARTING BONUSES", items: [] },
        { id: 'vitality1', tier: 1 },
        { id: 'vitality2', tier: 2 },
        { id: 'vitality3', tier: 3 },
        { id: 'attunement1', tier: 1 },
        { id: 'attunement2', tier: 2 },
        { id: 'attunement3', tier: 3 },
        { section: "QUALITY OF LIFE", items: [] },
        { id: 'signalSight' },
        { id: 'momentum' },
        { id: 'lastStand' },
      ]

      let startY = 120
      let selectedIndex = 0
      const selectableItems = []
      const itemLabels = []

      upgradeRows.forEach((row, i) => {
        const y = startY + i * 32

        if (row.section) {
          // section header
          add([
            text(row.section, { size: 14 }),
            pos(center().x, y),
            anchor("center"),
            color(hexToRgb(PALETTE.textDim)),
          ])
        } else {
          // upgrade item
          const unlock = UNLOCKS[row.id]
          const owned = hasUnlock(row.id)
          const available = canPurchase(row.id)
          const locked = unlock.requires && !hasUnlock(unlock.requires)

          selectableItems.push({ id: row.id, y, unlock })

          // layout: centered under title
          // cursor(-250) checkbox(-220) name(-180 to +20) status(+80 to +180)
          const baseX = center().x - 50  // shift whole row left

          // checkbox
          const checkColor = owned ? [0, 255, 100] : (available ? hexToRgb(PALETTE.upgrade) : [80, 80, 100])
          add([
            text(owned ? "(x)" : "( )", { size: 16 }),
            pos(baseX - 170, y),
            anchor("left"),
            color(...checkColor),
          ])

          // name
          const nameColor = owned ? [100, 255, 150] : (available ? hexToRgb(PALETTE.text) : [80, 80, 100])
          add([
            text(unlock.name, { size: 16 }),
            pos(baseX - 130, y),
            anchor("left"),
            color(...nameColor),
          ])

          // cost or status
          let statusText = ""
          let statusColor = [80, 80, 100]
          if (owned) {
            statusText = "OWNED"
            statusColor = [100, 255, 150]
          } else if (locked) {
            statusText = "LOCKED"
            statusColor = [100, 80, 80]
          } else if (available) {
            statusText = `${unlock.cost} Echo`
            statusColor = hexToRgb(PALETTE.upgrade)
          } else {
            statusText = `${unlock.cost} Echo`
            statusColor = [80, 80, 100]
          }

          add([
            text(statusText, { size: 14 }),
            pos(baseX + 120, y),
            anchor("left"),
            color(...statusColor),
          ])
        }
      })

      // selection cursor
      const baseX = center().x - 50
      const cursor = add([
        text(">", { size: 20 }),
        pos(baseX - 190, selectableItems[0]?.y || 150),
        anchor("center"),
        color(255, 0, 64),
      ])

      // description for selected item (shown at bottom of list)
      const descY = 120 + upgradeRows.length * 32 + 20
      const descText = add([
        text("", { size: 13 }),
        pos(center().x, descY),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      function updateDescription() {
        const item = selectableItems[selectedIndex]
        if (item && item.unlock) {
          descText.text = item.unlock.desc
        } else {
          descText.text = ""
        }
      }
      updateDescription()

      function updateCursor() {
        if (selectableItems[selectedIndex]) {
          cursor.pos.y = selectableItems[selectedIndex].y
        }
        updateDescription()
      }

      function refreshScene() {
        go("upgrades")
      }

      onKeyPress("up", () => {
        selectedIndex = Math.max(0, selectedIndex - 1)
        updateCursor()
      })

      onKeyPress("down", () => {
        selectedIndex = Math.min(selectableItems.length - 1, selectedIndex + 1)
        updateCursor()
      })

      // message display for feedback
      const messageText = add([
        text("", { size: 14 }),
        pos(center().x, height() - 80),
        anchor("center"),
        color(255, 100, 100),
        opacity(0),
      ])

      let messageTimer = null
      function showMessage(msg, col = [255, 100, 100]) {
        messageText.text = msg
        messageText.color = Color.fromArray(col)
        messageText.opacity = 1
        if (messageTimer) messageTimer.cancel()
        messageTimer = wait(3, () => { messageText.opacity = 0 })
      }

      function tryPurchase() {
        const item = selectableItems[selectedIndex]
        if (!item) return

        const unlock = UNLOCKS[item.id]

        // if owned, try to sell
        if (hasUnlock(item.id)) {
          const dependent = hasDependentUnlock(item.id)
          if (dependent) {
            const depName = UNLOCKS[dependent].name
            showMessage(`Sell ${depName} first`, [255, 150, 100])
            return
          }
          sellUnlock(item.id)
          showMessage(`+${unlock.cost} Echo refunded`, [100, 200, 255])
          refreshScene()
          return
        }

        if (unlock.requires && !hasUnlock(unlock.requires)) {
          showMessage("Unlock previous tier first", [255, 150, 100])
          return
        }
        if (saveData.echo < unlock.cost) {
          showMessage(`Need ${unlock.cost - saveData.echo} more Echo. Earn Echo by reaching deeper depths!`, [255, 200, 100])
          return
        }

        purchaseUnlock(item.id)
        refreshScene()
      }

      onKeyPress("enter", tryPurchase)
      onKeyPress("space", tryPurchase)

      // hints
      add([
        text("ESC - Back | ENTER/SPACE - Buy/Sell", { size: 14 }),
        pos(center().x, height() - 50),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      add([
        text("Echo is earned when a run ends. Deeper = more Echo.", { size: 12 }),
        pos(center().x, height() - 30),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      onKeyPress("escape", () => go("menu"))
    })

    // ============================================
    // MAIN GAME SCENE
    // ============================================
    scene("game", () => {
      // apply unlocks to starting stats
      const startStats = getStartingStats()
      let signal = startStats.signal
      let health = startStats.health
      const maxHealth = startStats.health
      const maxSignal = startStats.signal

      // debug: log starting stats
      console.log("[GAME START] startStats:", JSON.stringify(startStats))
      console.log("[GAME START] saveData.stats:", JSON.stringify(saveData.stats))
      console.log("[GAME START] saveData.unlocks:", JSON.stringify(saveData.unlocks))

      let facingDir = 1
      let isSlashing = false
      let slashCooldown = 0
      let isDashing = false
      let dashCooldown = 0
      let dashTimer = 0
      let dashDir = 1
      let iFrames = 0
      let auraTimer = 0
      let lastMoveDir = 0
      let walkFrame = 0
      let walkTimer = 0
      let depth = 1
      let score = 0
      let transitioning = false
      let inUpgradeRoom = false
      let isDead = false  // prevent multiple death triggers

      // show spectrum bonuses at game start if any exist
      const bonusHealth = saveData.stats.bonusHealth || 0
      const bonusSignal = saveData.stats.bonusSignal || 0
      const bonusDamage = saveData.stats.bonusDamage || 0
      const bonusRegen = saveData.stats.bonusRegen || 0
      const hasSpectrumBonuses = bonusHealth > 0 || bonusSignal > 0 || bonusDamage > 0 || bonusRegen > 0

      if (hasSpectrumBonuses) {
        // build bonus text
        const bonuses = []
        if (bonusHealth > 0) bonuses.push(`+${bonusHealth.toFixed(1)} HP`)
        if (bonusSignal > 0) bonuses.push(`+${bonusSignal.toFixed(1)} Signal`)
        if (bonusDamage > 0) bonuses.push(`+${bonusDamage.toFixed(2)} Damage`)
        if (bonusRegen > 0) bonuses.push(`+${bonusRegen.toFixed(2)} Regen`)

        const bonusText = add([
          text(`Spectrum memory: ${bonuses.join(", ")}`, { size: 12 }),
          pos(center().x, 100),
          anchor("center"),
          color(255, 0, 64),
          opacity(1),
          fixed(),
          z(Z.HUD + 10),
        ])

        // fade out after 3 seconds
        wait(2, () => {
          tween(bonusText.opacity, 0, 1, (v) => bonusText.opacity = v).then(() => {
            destroy(bonusText)
          })
        })
      }

      // score values per enemy type
      const SCORE_VALUES = {
        grunt: 10,
        spitter: 25,
        rusher: 50,
        drifter: 30,
        pillar: 75,
      }

      // === PLAYER UPGRADES ===
      const playerStats = {
        maxHealth: maxHealth,                    // from persistent unlocks
        maxSignal: maxSignal,                    // from persistent unlocks
        slashDamage: startStats.damage,          // from persistent unlocks + fever dreams
        moveSpeed: SPEED,
        dashDistance: DASH_DISTANCE,
        signalRegen: startStats.signalRegen,     // from persistent unlocks + fever dreams
      }

      const UPGRADES = [
        { id: "health1", name: "Vitality", desc: "+2 Max Health", apply: () => { playerStats.maxHealth += 2; health = Math.min(health + 2, playerStats.maxHealth) } },
        { id: "health2", name: "Resilience", desc: "+1 Max Health", apply: () => { playerStats.maxHealth += 1; health = Math.min(health + 1, playerStats.maxHealth) } },
        { id: "signal1", name: "Attunement", desc: "+3 Max Signal", apply: () => { playerStats.maxSignal += 3 } },
        { id: "signal2", name: "Flow", desc: "+50% Signal Regen", apply: () => { playerStats.signalRegen *= 1.5 } },
        { id: "damage1", name: "Sharp Edge", desc: "+1 Slash Damage", apply: () => { playerStats.slashDamage += 1 } },
        { id: "speed1", name: "Swift", desc: "+20% Move Speed", apply: () => { playerStats.moveSpeed *= 1.2 } },
        { id: "dash1", name: "Long Dash", desc: "+50% Dash Distance", apply: () => { playerStats.dashDistance *= 1.5 } },
        { id: "heal1", name: "Second Wind", desc: "Restore 3 Health", apply: () => { health = Math.min(health + 3, playerStats.maxHealth) } },
      ]

      let appliedUpgrades = []
      let usedFragments = []  // track used voice fragments this run
      let lastFragmentDepth = 0  // track when we last showed a fragment

      // === SISTER'S VOICE FRAGMENTS ===
      const VOICE_FRAGMENTS = {
        early: [  // depth 1-5
          "You came.",
          "I knew you'd find me.",
          "Keep coming...",
          "I can feel you. Faintly.",
          "They don't understand what I am.",
        ],
        middle: [  // depth 6-10
          "The Static... it's not random. It's searching.",
          "They want to use me to silence everything.",
          "You're the only signal I can still feel.",
          "Every step you take, I feel it through the threads.",
          "Don't stop. Whatever happens, don't stop.",
        ],
        late: [  // depth 11-15
          "I can see the whole spectrum now. It's beautiful... and terrifying.",
          "Don't trust the silence. That's where they hide.",
          "Almost. You're almost here.",
          "I've been holding on. Waiting for your signal.",
          "They're scared of you. I can feel their fear.",
        ],
        final: [  // depth 16+
          "I can hear your blade. I can feel you fighting.",
          "One more push. I'm right here.",
          "Together we can fix this. All of it.",
          "I see you. I finally see you.",
          "...",
        ],
      }

      function getFragmentPool(d) {
        if (d <= 5) return VOICE_FRAGMENTS.early
        if (d <= 10) return VOICE_FRAGMENTS.middle
        if (d <= 15) return VOICE_FRAGMENTS.late
        return VOICE_FRAGMENTS.final
      }

      function maybeShowFragment(d) {
        // don't show on first room or upgrade/rest rooms
        if (d <= 1) return
        // show every 2-3 rooms on average (40% chance)
        if (d - lastFragmentDepth < 2) return
        if (Math.random() > 0.4) return

        const pool = getFragmentPool(d)
        const available = pool.filter(f => !usedFragments.includes(f))
        if (available.length === 0) return

        const fragment = available[Math.floor(Math.random() * available.length)]
        usedFragments.push(fragment)
        lastFragmentDepth = d

        showVoiceFragment(fragment)
      }

      function showVoiceFragment(msg) {
        const fragText = add([
          text(msg, { size: 18 }),
          pos(center().x, center().y),
          anchor("center"),
          color(255, 100, 120),
          opacity(0),
          z(Z.HUD + 100),
        ])

        // fade in, hold, fade out
        tween(fragText.opacity, 0.9, 0.5, (v) => fragText.opacity = v).then(() => {
          wait(2, () => {
            tween(fragText.opacity, 0, 0.5, (v) => fragText.opacity = v).then(() => {
              destroy(fragText)
            })
          })
        })
      }

      add([sprite("bg"), pos(0, 0), z(Z.BG)])
      loop(0.25, spawnAmbientParticle)

      // === GROUND (solid, not one-way) ===
      add([
        sprite("ground"),
        pos(0, height() - 48),
        area(),
        body({ isStatic: true }),
        z(Z.PLATFORMS),
        "ground",
      ])

      // === PLATFORMS (one-way) ===
      function addOneWayPlatform(spr, x, y) {
        return add([
          sprite(spr),
          pos(x, y),
          area(),
          body({ isStatic: true }),
          z(Z.PLATFORMS),
          "platform",
          "oneWay",
        ])
      }

      // platform layout patterns
      const ROOM_PATTERNS = [
        // pattern 0: staircase right
        [["lg", 80, 450], ["md", 350, 380], ["sm", 550, 300]],
        // pattern 1: staircase left
        [["sm", 100, 300], ["md", 280, 380], ["lg", 480, 450]],
        // pattern 2: two levels
        [["lg", 100, 450], ["lg", 500, 450], ["md", 300, 300]],
        // pattern 3: scattered
        [["sm", 150, 400], ["sm", 400, 350], ["sm", 600, 400], ["md", 280, 250]],
        // pattern 4: high path
        [["md", 80, 350], ["sm", 300, 280], ["md", 500, 350]],
      ]

      function generateRoom() {
        // clear existing platforms, enemies, projectiles, and special room elements
        get("platform").forEach(destroy)
        get("enemy").forEach(destroy)
        get("projectile").forEach(destroy)
        get("upgradeUI").forEach(destroy)
        get("restShrine").forEach(destroy)

        // pick random pattern
        const pattern = ROOM_PATTERNS[Math.floor(Math.random() * ROOM_PATTERNS.length)]

        // create platforms
        pattern.forEach(([size, x, y]) => {
          const spr = size === "lg" ? "platform-lg" : size === "md" ? "platform-md" : "platform-sm"
          addOneWayPlatform(spr, x, y)
        })

        // spawn enemies based on depth (gentler early ramp)
        const crawlerCount = Math.min(1 + Math.floor(depth / 2), 4)  // 1, 1, 2, 2, 3, 3, 4...
        const spitterCount = depth >= 3 ? Math.min(Math.floor((depth - 2) / 2), 2) : 0  // 0, 0, 0, 1, 1, 2...
        const rusherCount = depth >= 4 ? Math.min(Math.floor((depth - 3) / 3), 2) : 0  // 0, 0, 0, 0, 1, 1, 1, 2...
        const drifterCount = depth >= 6 ? Math.min(Math.floor((depth - 5) / 3), 2) : 0  // after first upgrade
        const pillarCount = depth >= 7 ? Math.min(Math.floor((depth - 6) / 4), 2) : 0  // tanks at depth 7+

        // spawn crawlers
        for (let i = 0; i < crawlerCount; i++) {
          const spawnX = 400 + Math.random() * 350
          const spawnY = 300 + Math.random() * 150
          wait(0.5 + i * 0.5, () => spawnCrawler(spawnX, spawnY))
        }

        // spawn spitters (elevated positions)
        for (let i = 0; i < spitterCount; i++) {
          const spawnX = 500 + Math.random() * 250
          const spawnY = 250 + Math.random() * 100
          wait(1 + i * 1, () => spawnSpitter(spawnX, spawnY))
        }

        // spawn rushers (ground level - they charge horizontally)
        for (let i = 0; i < rusherCount; i++) {
          const spawnX = 550 + Math.random() * 200
          wait(1.5 + i * 1.5, () => spawnRusher(spawnX, height() - 48))
        }

        // spawn drifters (floating in air)
        for (let i = 0; i < drifterCount; i++) {
          const spawnX = 450 + Math.random() * 300
          const spawnY = 150 + Math.random() * 150  // upper area
          wait(2 + i * 1, () => spawnDrifter(spawnX, spawnY))
        }

        // spawn pillars (ground level tanks)
        for (let i = 0; i < pillarCount; i++) {
          const spawnX = 500 + Math.random() * 250
          wait(2.5 + i * 2, () => spawnPillar(spawnX, height() - 48))
        }
      }

      // generate initial room
      generateRoom()

      // === PLAYER ===
      const player = add([
        sprite("redeye"),
        pos(100, 400),
        area(),
        body(),
        anchor("bot"),
        scale(1),
        z(Z.PLAYER),
        "player",
        {
          canDoubleJump: false,
          hasJumped: false,
          wasGrounded: true,
        }
      ])

      // sword arm (hidden by default)
      const swordArm = add([
        sprite("sword-arm"),
        pos(0, 0),
        anchor("left"),  // pivot from hilt
        scale(1),
        opacity(0),
        z(Z.SLASH),
      ])

      setGravity(GRAVITY_RISE)

      // === ONE-WAY PLATFORM LOGIC ===
      player.onBeforePhysicsResolve((collision) => {
        // only affect platforms tagged "oneWay"
        if (!collision.target.is("oneWay")) return

        // pass through when moving up, collide when falling
        if (player.vel.y < 0) {
          collision.preventResolution()
        }
      })

      // === CRAWLER ENEMY SYSTEM ===
      const CRAWLER_SPEED = 120
      let playerInvincible = false
      let invincibleTimer = 0

      function spawnCrawler(x, y) {
        const crawler = add([
          sprite("crawler"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "crawler",
          {
            hp: 1,
          }
        ])

        // AI: move toward player using position directly
        crawler.onUpdate(() => {
          if (!crawler.exists() || !crawler.scale || !player.exists()) return

          // move toward player
          const dir = player.pos.x > crawler.pos.x ? 1 : -1
          crawler.pos.x += CRAWLER_SPEED * dir * dt()
          crawler.scale.x = dir
        })

        // fall death
        crawler.onUpdate(() => {
          if (!crawler.exists()) return
          if (crawler.pos.y > height() + 50) {
            destroy(crawler)
          }
        })

        return crawler
      }

      // === SPITTER ENEMY ===
      const SPITTER_FIRE_RATE = 2.0  // seconds between shots
      const SPITTER_TELEGRAPH = 0.5  // glow before firing
      const PROJECTILE_SPEED = 250

      function spawnSpitter(x, y) {
        const spitter = add([
          sprite("spitter"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "spitter",
          {
            hp: 2,
            fireTimer: SPITTER_FIRE_RATE,
            telegraphing: false,
          }
        ])

        // telegraph glow effect (child object)
        const mouthGlow = add([
          circle(6),
          pos(0, 0),
          color(255, 100, 100),
          opacity(0),
          anchor("center"),
          z(Z.PLATFORMS + 2),
        ])

        spitter.onUpdate(() => {
          if (!spitter.exists() || !player.exists()) {
            if (mouthGlow.exists()) destroy(mouthGlow)
            return
          }

          // update mouth glow position
          mouthGlow.pos = vec2(spitter.pos.x, spitter.pos.y - 26)

          // fire timer
          spitter.fireTimer -= dt()

          // telegraph phase - tilt toward player
          if (spitter.fireTimer <= SPITTER_TELEGRAPH && !spitter.telegraphing) {
            spitter.telegraphing = true
            mouthGlow.opacity = 0.8
            // tilt toward player
            const toPlayer = player.pos.sub(spitter.pos)
            const tiltAngle = Math.atan2(toPlayer.y, toPlayer.x) * (180 / Math.PI) + 90
            spitter.angle = Math.max(-30, Math.min(30, tiltAngle))
          }

          // fire projectile
          if (spitter.fireTimer <= 0) {
            spitter.fireTimer = SPITTER_FIRE_RATE
            spitter.telegraphing = false
            mouthGlow.opacity = 0
            spitter.angle = 0  // reset tilt

            // calculate direction to player
            const dir = player.pos.sub(spitter.pos).unit()
            const mouthPos = vec2(spitter.pos.x, spitter.pos.y - 26)

            // boom effect from mouth
            for (let i = 0; i < 8; i++) {
              add([
                circle(rand(3, 6)),
                pos(mouthPos.x + rand(-5, 5), mouthPos.y + rand(-5, 5)),
                color(255, 255, 255),
                opacity(1),
                move(rand(0, 360), rand(60, 120)),
                lifespan(0.2, { fade: 0.1 }),
                z(Z.PARTICLES),
              ])
            }
            // flash at mouth
            const flash = add([
              circle(12),
              pos(mouthPos),
              color(255, 255, 255),
              opacity(0.9),
              anchor("center"),
              z(Z.PARTICLES),
            ])
            tween(flash.opacity, 0, 0.15, (v) => flash.opacity = v).then(() => destroy(flash))

            // spawn projectile
            const proj = add([
              sprite("projectile"),
              pos(mouthPos),
              area(),
              anchor("center"),
              z(Z.PARTICLES),
              "projectile",
              "enemyProjectile",
            ])

            proj.onUpdate(() => {
              if (!proj.exists()) return
              proj.pos = proj.pos.add(dir.scale(PROJECTILE_SPEED * dt()))

              // destroy if off screen
              if (proj.pos.x < -20 || proj.pos.x > width() + 20 ||
                  proj.pos.y < -20 || proj.pos.y > height() + 20) {
                destroy(proj)
              }
            })

            // projectile damages player
            proj.onCollide("player", () => {
              if (playerInvincible) {
                destroy(proj)
                return
              }
              health -= 1
              healthText.text = "HEALTH: " + "".repeat(Math.max(0, health))
              destroy(proj)

              if (health <= 0 && !isDead) {
                isDead = true
                console.log("[DEATH] Projectile kill - health:", health, "depth:", depth, "score:", score)
                go("feverDream", { depth, score })
                return
              }

              playerInvincible = true
              invincibleTimer = 1.5
              player.opacity = 0.5
              shake(5)
            })
          }
        })

        // clean up glow on death
        spitter.onDestroy(() => {
          if (mouthGlow.exists()) destroy(mouthGlow)
        })

        // fall death
        spitter.onUpdate(() => {
          if (!spitter.exists()) return
          if (spitter.pos.y > height() + 50) {
            destroy(spitter)
          }
        })

        return spitter
      }

      // === RUSHER ENEMY ===
      const RUSHER_CHARGE_SPEED = 600
      const RUSHER_TELEGRAPH = 0.7
      const RUSHER_STUN_TIME = 1.0
      const RUSHER_SIGHT_RANGE = 40  // vertical range to detect player

      function spawnRusher(x, y) {
        const rusher = add([
          sprite("rusher"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "rusher",
          {
            hp: 2,
            damage: 2,  // deals 2 damage
            state: "idle",  // idle, telegraph, charging, stunned
            stateTimer: 0,
            chargeDir: 1,
            originalX: x,
          }
        ])

        rusher.onUpdate(() => {
          if (!rusher.exists() || !rusher.scale || !player.exists()) return

          // state machine
          if (rusher.state === "idle") {
            // check if player is in horizontal line of sight
            const dy = Math.abs(player.pos.y - rusher.pos.y)
            if (dy < RUSHER_SIGHT_RANGE) {
              // start telegraph
              rusher.state = "telegraph"
              rusher.stateTimer = RUSHER_TELEGRAPH
              rusher.chargeDir = player.pos.x > rusher.pos.x ? 1 : -1
              rusher.scale.x = rusher.chargeDir
            }
          }
          else if (rusher.state === "telegraph") {
            // vibrate/shake during telegraph
            rusher.pos.x += Math.sin(time() * 50) * 2
            rusher.stateTimer -= dt()

            // flash red
            if (Math.floor(time() * 10) % 2 === 0) {
              rusher.opacity = 0.6
            } else {
              rusher.opacity = 1
            }

            if (rusher.stateTimer <= 0) {
              rusher.state = "charging"
              rusher.opacity = 1
            }
          }
          else if (rusher.state === "charging") {
            // charge at high speed
            rusher.pos.x += RUSHER_CHARGE_SPEED * rusher.chargeDir * dt()

            // stop if hit wall (screen edge or traveled too far)
            if (rusher.pos.x < 20 || rusher.pos.x > width() - 20 ||
                Math.abs(rusher.pos.x - rusher.originalX) > 500) {
              rusher.state = "stunned"
              rusher.stateTimer = RUSHER_STUN_TIME
              rusher.originalX = rusher.pos.x
              // impact shake
              shake(4)
            }
          }
          else if (rusher.state === "stunned") {
            // vulnerable, flashing
            rusher.opacity = 0.4 + Math.sin(time() * 15) * 0.3
            rusher.stateTimer -= dt()

            if (rusher.stateTimer <= 0) {
              rusher.state = "idle"
              rusher.opacity = 1
            }
          }
        })

        // fall death
        rusher.onUpdate(() => {
          if (!rusher.exists()) return
          if (rusher.pos.y > height() + 50) {
            destroy(rusher)
          }
        })

        // stun when hitting player (prevents getting stuck)
        rusher.onCollide("player", () => {
          if (rusher.state === "charging") {
            rusher.state = "stunned"
            rusher.stateTimer = RUSHER_STUN_TIME
            rusher.originalX = rusher.pos.x
          }
        })

        return rusher
      }

      // === DRIFTER (floater, depth 5+) ===
      const DRIFTER_SPEED = 40  // slow drift toward player
      const DRIFTER_BOB_SPEED = 2  // sine wave frequency
      const DRIFTER_BOB_AMOUNT = 15  // sine wave amplitude

      function spawnDrifter(x, y) {
        const baseY = y
        const phaseOffset = Math.random() * Math.PI * 2  // random start phase

        const drifter = add([
          sprite("drifter"),
          pos(x, y),
          area({ scale: 0.7 }),  // smaller hitbox than visual
          anchor("center"),
          scale(1),
          opacity(0.9),
          z(Z.PLATFORMS + 1),
          "enemy",
          "drifter",
          {
            hp: 1,
            damage: 1,
            baseY: baseY,
          }
        ])

        drifter.onUpdate(() => {
          if (!drifter.exists() || !player.exists()) return

          // slowly drift toward player X
          const dx = player.pos.x - drifter.pos.x
          drifter.pos.x += Math.sign(dx) * DRIFTER_SPEED * dt()

          // bob up and down
          drifter.pos.y = drifter.baseY + Math.sin(time() * DRIFTER_BOB_SPEED + phaseOffset) * DRIFTER_BOB_AMOUNT

          // pulsing glow effect
          drifter.opacity = 0.7 + Math.sin(time() * 3 + phaseOffset) * 0.2

          // keep within bounds
          drifter.pos.x = Math.max(30, Math.min(width() - 30, drifter.pos.x))
        })

        return drifter
      }

      // === PILLAR (tank, depth 7+) ===
      const PILLAR_SPEED = 25  // very slow

      function spawnPillar(x, y) {
        const pillar = add([
          sprite("pillar"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "pillar",
          {
            hp: 4,
            damage: 1,
          }
        ])

        pillar.onUpdate(() => {
          if (!pillar.exists() || !pillar.scale || !player.exists()) return

          // slow walk toward player
          const dx = player.pos.x - pillar.pos.x
          pillar.pos.x += Math.sign(dx) * PILLAR_SPEED * dt()
          pillar.scale.x = dx > 0 ? 1 : -1

          // slight sway for menace
          pillar.angle = Math.sin(time() * 2) * 2
        })

        // fall death
        pillar.onUpdate(() => {
          if (!pillar.exists()) return
          if (pillar.pos.y > height() + 50) {
            destroy(pillar)
          }
        })

        return pillar
      }

      // === HEALTH DROPS ===
      function spawnHealthDrop(p) {
        const drop = add([
          circle(8),
          pos(p.x, p.y),
          area(),
          anchor("center"),
          color(255, 50, 80),
          opacity(1),
          z(Z.PARTICLES + 5),
          "healthDrop",
        ])

        // floating animation
        const startY = p.y
        drop.onUpdate(() => {
          if (!drop.exists()) return
          drop.pos.y = startY + Math.sin(time() * 4) * 5
          drop.opacity = 0.7 + Math.sin(time() * 6) * 0.3
        })

        // despawn after 8 seconds
        wait(8, () => { if (drop.exists()) destroy(drop) })
      }

      // player picks up health
      player.onCollide("healthDrop", (drop) => {
        if (health < playerStats.maxHealth) {
          health = Math.min(health + 1, playerStats.maxHealth)
          healthText.text = "HEALTH: " + "".repeat(health)
          floatingText(vec2(player.pos.x, player.pos.y - 40), "+1", [50, 255, 100])
        }
        destroy(drop)
      })

      // === PLAYER DAMAGE FROM ENEMIES ===
      let sisterPainTimer = 0  // sister feels your pain

      player.onCollide("enemy", (enemy) => {
        if (playerInvincible) return

        // check for enemy damage value (rusher deals 2)
        const dmg = enemy.damage || 1
        health -= dmg
        healthText.text = "HEALTH: " + "".repeat(Math.max(0, health))

        // sister feels the pain - she flickers sympathetically
        sisterPainTimer = 0.8

        if (health <= 0 && !isDead) {
          isDead = true
          console.log("[DEATH] Enemy collision - health:", health, "depth:", depth, "score:", score)
          go("feverDream", { depth, score })
          return
        }

        // i-frames
        playerInvincible = true
        invincibleTimer = 1.5

        // knockback
        const knockDir = player.pos.x > enemy.pos.x ? 1 : -1
        player.move(knockDir * 200, -150)

        // flash effect
        player.opacity = 0.5
        shake(5)
      })

      // sister pain flicker update
      onUpdate(() => {
        if (sisterPainTimer > 0) {
          sisterPainTimer -= dt()
          // rapid flicker while in pain
          if (Math.random() > 0.5) {
            sisterSignal.opacity = 0.1
          }
        }
      })

      // i-frame timer
      onUpdate(() => {
        if (playerInvincible) {
          invincibleTimer -= dt()
          // flicker effect
          player.opacity = Math.sin(time() * 30) > 0 ? 1 : 0.3
          if (invincibleTimer <= 0) {
            playerInvincible = false
            player.opacity = 1
          }
        }
      })


      // === HUD ===
      add([
        rect(204, 18),
        pos(18, 18),
        color(hexToRgb(PALETTE.signalEmpty)),
        fixed(),
        z(Z.HUD),
      ])

      const signalBar = add([
        rect(200, 14),
        pos(20, 20),
        color(255, 0, 64),
        fixed(),
        z(Z.HUD + 1),
      ])

      const signalText = add([
        text("SIGNAL: 10/10", { size: 14 }),
        pos(20, 42),
        color(hexToRgb(PALETTE.text)),
        fixed(),
        z(Z.HUD),
      ])

      const healthText = add([
        text("HEALTH: " + "".repeat(health) + "".repeat(maxHealth - health), { size: 16 }),
        pos(20, 62),
        color(255, 0, 64),
        fixed(),
        z(Z.HUD),
      ])

      const depthText = add([
        text("Depth: 1", { size: 14 }),
        pos(width() - 20, 20),
        anchor("topright"),
        color(hexToRgb(PALETTE.textDim)),
        fixed(),
        z(Z.HUD),
      ])

      const scoreText = add([
        text("Score: 0", { size: 14 }),
        pos(width() - 20, 40),
        anchor("topright"),
        color(255, 200, 50),
        fixed(),
        z(Z.HUD),
      ])

      // === EXIT ZONE (right side of screen) ===
      const exitZone = add([
        rect(30, height()),
        pos(width() - 30, 0),
        area(),
        opacity(0),
        "exit",
      ])

      // visual indicator for exit
      const exitGlow = add([
        rect(4, height() - 100),
        pos(width() - 10, 50),
        color(255, 0, 64),
        opacity(0.3),
        z(Z.PLATFORMS - 1),
      ])
      exitGlow.onUpdate(() => {
        exitGlow.opacity = 0.2 + Math.sin(time() * 3) * 0.15
      })

      // === REST ROOM ===
      const REST_ROOM_CHANCE = 0.12  // 12% chance

      function generateRestRoom() {
        // clear everything
        get("platform").forEach(destroy)
        get("enemy").forEach(destroy)
        get("projectile").forEach(destroy)
        get("upgradeUI").forEach(destroy)

        // simple safe room
        addOneWayPlatform("platform-lg", 300, 400)

        // shrine visual (glowing circle)
        const shrine = add([
          circle(20),
          pos(width() / 2, height() - 70),
          anchor("center"),
          color(100, 255, 150),
          opacity(0.8),
          z(Z.PLATFORMS + 2),
          "restShrine",
        ])

        // shrine glow effect
        shrine.onUpdate(() => {
          shrine.opacity = 0.5 + Math.sin(time() * 2) * 0.3
        })

        // particles around shrine
        loop(0.3, () => {
          if (!shrine.exists()) return
          add([
            circle(rand(2, 4)),
            pos(shrine.pos.x + rand(-30, 30), shrine.pos.y + rand(-10, 20)),
            color(100, 255, 150),
            opacity(0.7),
            move(90, rand(30, 60)),  // float up
            lifespan(0.8, { fade: 0.4 }),
            z(Z.PARTICLES),
          ])
        })

        // "REST" title
        add([
          text("SANCTUARY", { size: 28 }),
          pos(width() / 2, 100),
          anchor("center"),
          color(100, 255, 150),
          z(Z.HUD + 10),
          "upgradeUI",
        ])

        // heal player after brief delay
        wait(0.5, () => {
          const healAmount = 2
          const oldHealth = health
          health = Math.min(health + healAmount, playerStats.maxHealth)
          const healed = health - oldHealth

          if (healed > 0) {
            floatingText(vec2(player.pos.x, player.pos.y - 40), `+${healed} HP`, [100, 255, 150])
          }
          updateHUD()

          // show continue hint
          add([
            text(" Continue", { size: 18 }),
            pos(width() - 80, height() / 2),
            anchor("center"),
            color(255, 255, 255),
            opacity(0.7),
            z(Z.HUD + 5),
            "upgradeUI",
          ])
        })
      }

      // === UPGRADE ROOM ===
      function generateUpgradeRoom() {
        // clear everything
        get("platform").forEach(destroy)
        get("enemy").forEach(destroy)
        get("projectile").forEach(destroy)
        get("upgradeUI").forEach(destroy)
        get("restShrine").forEach(destroy)

        inUpgradeRoom = true

        // simple safe room - just one central platform
        addOneWayPlatform("platform-lg", 300, 400)

        // show upgrade choices after brief delay
        wait(0.3, () => showUpgradeChoice())
      }

      function showUpgradeChoice() {
        // pick 2 random upgrades that haven't been applied
        const available = UPGRADES.filter(u => !appliedUpgrades.includes(u.id))
        if (available.length < 2) return  // no more upgrades

        const shuffled = available.sort(() => Math.random() - 0.5)
        const choices = shuffled.slice(0, 2)

        // title
        add([
          text("UPGRADE", { size: 32 }),
          pos(width() / 2, 100),
          anchor("center"),
          color(255, 0, 64),
          z(Z.HUD + 10),
          "upgradeUI",
        ])

        // create upgrade option boxes
        choices.forEach((upgrade, i) => {
          const boxX = width() / 2 - 150 + i * 300
          const boxY = 280

          // box background
          const box = add([
            rect(200, 140, { radius: 8 }),
            pos(boxX, boxY),
            anchor("center"),
            color(30, 30, 40),
            outline(2, { color: rgb(100, 100, 120) }),
            area(),
            z(Z.HUD + 10),
            "upgradeUI",
            "upgradeBox",
            { upgradeData: upgrade, selected: false },
          ])

          // upgrade name
          add([
            text(upgrade.name, { size: 20 }),
            pos(boxX, boxY - 35),
            anchor("center"),
            color(255, 255, 255),
            z(Z.HUD + 11),
            "upgradeUI",
          ])

          // upgrade description
          add([
            text(upgrade.desc, { size: 14 }),
            pos(boxX, boxY + 5),
            anchor("center"),
            color(180, 180, 180),
            z(Z.HUD + 11),
            "upgradeUI",
          ])

          // key hint
          add([
            text(`Press ${i + 1}`, { size: 18 }),
            pos(boxX, boxY + 45),
            anchor("center"),
            color(255, 0, 64),
            z(Z.HUD + 11),
            "upgradeUI",
          ])
        })

        // handle keyboard selection
        const key1 = onKeyPress("1", () => {
          selectUpgrade(choices[0])
          key1.cancel()
          key2.cancel()
        })
        const key2 = onKeyPress("2", () => {
          selectUpgrade(choices[1])
          key1.cancel()
          key2.cancel()
        })
      }

      function selectUpgrade(upgrade) {
        // apply the upgrade
        upgrade.apply()
        appliedUpgrades.push(upgrade.id)

        // flash effect
        get("upgradeUI").forEach(destroy)

        // show confirmation
        const confirmText = add([
          text(`${upgrade.name}!`, { size: 28 }),
          pos(width() / 2, 200),
          anchor("center"),
          color(0, 255, 128),
          opacity(1),
          z(Z.HUD + 10),
          "upgradeUI",
        ])

        // particles
        for (let i = 0; i < 20; i++) {
          add([
            circle(rand(3, 6)),
            pos(width() / 2 + rand(-100, 100), 200 + rand(-30, 30)),
            color(0, 255, 128),
            opacity(1),
            move(rand(0, 360), rand(50, 150)),
            lifespan(0.5, { fade: 0.3 }),
            z(Z.PARTICLES),
          ])
        }

        // clear upgrade room flag and show exit hint
        wait(0.8, () => {
          destroy(confirmText)
          inUpgradeRoom = false

          add([
            text(" Continue", { size: 18 }),
            pos(width() - 80, height() / 2),
            anchor("center"),
            color(255, 255, 255),
            opacity(0.7),
            z(Z.HUD + 5),
            "upgradeUI",
          ])
        })
      }

      // === ROOM TRANSITION ===
      function nextRoom() {
        if (transitioning) return
        transitioning = true

        // brief flash
        const flash = add([
          rect(width(), height()),
          pos(0, 0),
          color(0, 0, 0),
          opacity(0),
          z(Z.HUD + 50),
        ])

        // fade to black
        tween(flash.opacity, 1, 0.2, (v) => flash.opacity = v, easings.linear).then(() => {
          // increment depth
          depth++
          depthText.text = `Depth: ${depth}`

          // maybe show sister's voice
          maybeShowFragment(depth)

          // reset player position
          player.pos = vec2(80, 400)
          facingDir = 1
          player.scale.x = 1

          // check for special rooms
          if (depth > 0 && depth % 5 === 0) {
            // upgrade room every 5 depths
            generateUpgradeRoom()
          } else if (depth > 1 && Math.random() < REST_ROOM_CHANCE) {
            // random rest room (not on depth 1)
            generateRestRoom()
          } else {
            generateRoom()
          }

          // fade back in
          tween(flash.opacity, 0, 0.2, (v) => flash.opacity = v, easings.linear).then(() => {
            destroy(flash)
            transitioning = false
          })
        })
      }

      // trigger transition when player enters exit zone
      player.onCollide("exit", () => {
        // block exit if in upgrade room and hasn't selected yet
        if (inUpgradeRoom) return
        nextRoom()
      })

      const sisterSignal = add([
        circle(8),
        pos(width() - 40, 50),
        color(255, 0, 64),
        opacity(1),
        anchor("center"),
        fixed(),
        z(Z.HUD),
      ])

      add([
        text("Arrow keys: Move | Space: Jump | Shift: Dash | X: Slash | R: Restart", { size: 12 }),
        pos(width()/2, height() - 15),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
        fixed(),
        z(Z.HUD),
      ])

      function updateHUD() {
        signalBar.width = (signal / playerStats.maxSignal) * 200
        signalText.text = `SIGNAL: ${Math.floor(signal)}/${playerStats.maxSignal}`
        if (signal < 3) {
          signalBar.opacity = 0.5 + Math.sin(time() * 10) * 0.5
        } else {
          signalBar.opacity = 1
        }
        const hp = Math.max(0, health)
        const maxHp = playerStats.maxHealth
        healthText.text = "HEALTH: " + "".repeat(hp) + "".repeat(maxHp - hp)
      }

      // === HYBRID GRAVITY ===
      player.onUpdate(() => {
        if (player.vel && player.vel.y < 0) {
          setGravity(GRAVITY_RISE)
        } else {
          setGravity(GRAVITY_FALL)
        }
        if (player.vel && player.vel.y > MAX_FALL_SPEED) {
          player.vel.y = MAX_FALL_SPEED
        }
      })

      // === MOVEMENT & ANIMATION ===
      onUpdate(() => {
        if (isDashing) return

        lastMoveDir = 0
        let isMoving = false

        if (isKeyDown("left") || isKeyDown("a")) {
          player.move(-playerStats.moveSpeed, 0)
          facingDir = -1
          lastMoveDir = -1
          isMoving = true
        }
        if (isKeyDown("right") || isKeyDown("d")) {
          player.move(playerStats.moveSpeed, 0)
          facingDir = 1
          lastMoveDir = 1
          isMoving = true
        }

        // update facing
        player.scale.x = facingDir
        swordArm.scale.x = facingDir

        // signal regen/drain
        if (lastMoveDir === 1) {
          signal = Math.min(playerStats.maxSignal, signal + SIGNAL_REGEN_RIGHT * playerStats.signalRegen * dt())
        } else if (lastMoveDir === -1) {
          signal = Math.max(0, signal - SIGNAL_DRAIN_LEFT * dt())
        } else {
          signal = Math.max(0, signal - SIGNAL_DRAIN_STILL * dt())
        }

        updateHUD()
      })

      // === JUMP ===
      onKeyPress("space", () => {
        if (isDashing) return

        if (player.isGrounded()) {
          player.jump(JUMP_FORCE)
          player.hasJumped = false

          for (let i = 0; i < 5; i++) {
            add([
              circle(rand(2, 4)),
              pos(player.pos.x + rand(-10, 10), player.pos.y + 25),
              color(150, 150, 160),
              opacity(0.5),
              move(rand(60, 120), rand(30, 60)),
              lifespan(0.3, { fade: 0.2 }),
              z(Z.PARTICLES),
            ])
          }
        } else if (player.canDoubleJump && !player.hasJumped) {
          player.jump(JUMP_FORCE * 0.85)
          player.hasJumped = true
          signal = Math.max(0, signal - 1)
        }
      })

      onKeyDown("space", () => {
        if (player.vel && player.vel.y < 0) {
          setGravity(GRAVITY_RISE * 0.8)
        }
      })

      // === DASH ===
      onKeyPress("shift", () => {
        if (isDashing || dashCooldown > 0 || signal < DASH_COST) return

        isDashing = true
        dashTimer = DASH_DURATION
        dashDir = facingDir
        iFrames = DASH_DURATION + 0.05
        signal -= DASH_COST

        player.scale.x = facingDir * 1.5
        player.scale.y = 0.7

        spawnAfterimage(player)
      })

      onUpdate(() => {
        if (isDashing) {
          const dashSpeed = playerStats.dashDistance / DASH_DURATION
          player.move(dashSpeed * dashDir, 0)
          dashTimer -= dt()

          if (Math.random() < 0.5) spawnAfterimage(player)

          if (dashTimer <= 0) {
            isDashing = false
            dashCooldown = 0.2
            player.scale = vec2(facingDir, 1)
          }
        }

        if (dashCooldown > 0) dashCooldown -= dt()
        if (iFrames > 0) iFrames -= dt()
      })

      // === SLASH ===
      function performSlash() {
        if (isSlashing || slashCooldown > 0) return
        if (signal < SLASH_COST) {
          floatingText(vec2(player.pos.x, player.pos.y - 32), "NO SIGNAL", [255, 100, 100])
          return
        }

        isSlashing = true
        slashCooldown = SLASH_DURATION + 0.1
        signal -= SLASH_COST

        // show sword blade - positioned at chest level (bot anchor, so y - 40)
        swordArm.opacity = 1
        swordArm.scale = vec2(facingDir * 1.5, 1.5)
        swordArm.pos = vec2(player.pos.x + facingDir * 10, player.pos.y - 40)
        swordArm.angle = -70

        // animate sword swing
        let slashProgress = 0
        const slashUpdate = swordArm.onUpdate(() => {
          slashProgress += dt() / SLASH_DURATION
          swordArm.angle = -70 + slashProgress * 120
          swordArm.pos = vec2(
            player.pos.x + facingDir * 10,
            player.pos.y - 40 + slashProgress * 15
          )
          swordArm.scale = vec2(facingDir * 1.5, 1.5)
          if (slashProgress >= 1) {
            slashUpdate.cancel()
          }
        })

        // slash arc effect
        const slashArc = add([
          sprite("slash-arc"),
          pos(player.pos.x + facingDir * 40, player.pos.y - 32),
          anchor("center"),
          scale(facingDir * 1.2, 1.2),
          opacity(1),
          z(Z.SLASH),
        ])

        // manually check and damage enemies in slash range
        const slashX = player.pos.x + facingDir * 40
        const slashY = player.pos.y - 20
        get("enemy").forEach((enemy) => {
          if (!enemy.exists()) return
          const dx = Math.abs(enemy.pos.x - slashX)
          const dy = Math.abs(enemy.pos.y - slashY)
          // hit enemies within range (horizontal: 60px, vertical: 50px)
          if (dx < 60 && dy < 50) {
            enemy.hp = (enemy.hp || 1) - playerStats.slashDamage
            shake(3)
            // flash white on hit
            enemy.color = rgb(255, 255, 255)
            wait(0.1, () => { if (enemy.exists()) enemy.color = rgb(255, 255, 255) })

            if (enemy.hp <= 0) {
              spawnStaticBurst(enemy.pos)
              // chance to drop health
              if (Math.random() < HEALTH_DROP_CHANCE) {
                spawnHealthDrop(enemy.pos)
              }
              // award score based on enemy type
              const enemyType = enemy.is("grunt") ? "grunt" :
                               enemy.is("spitter") ? "spitter" :
                               enemy.is("rusher") ? "rusher" :
                               enemy.is("drifter") ? "drifter" :
                               enemy.is("pillar") ? "pillar" : "grunt"
              score += SCORE_VALUES[enemyType] || 10
              scoreText.text = "Score: " + score
              destroy(enemy)
            }
          }
        })

        // slash deflects projectiles
        get("projectile").forEach((proj) => {
          if (!proj.exists()) return
          const dx = Math.abs(proj.pos.x - slashX)
          const dy = Math.abs(proj.pos.y - slashY)
          if (dx < 60 && dy < 50) {
            // deflect spark effect
            for (let i = 0; i < 5; i++) {
              add([
                circle(rand(2, 4)),
                pos(proj.pos),
                color(255, 200, 100),
                opacity(1),
                move(rand(0, 360), rand(80, 150)),
                lifespan(0.15, { fade: 0.1 }),
                z(Z.PARTICLES),
              ])
            }
            destroy(proj)
          }
        })

        // animate arc fade
        slashArc.onUpdate(() => {
          slashArc.opacity -= dt() * 5
        })

        slashBurst(vec2(player.pos.x, player.pos.y - 32), facingDir)
        shake(5)

        wait(SLASH_DURATION, () => {
          destroy(slashArc)
          swordArm.opacity = 0
          swordArm.angle = 0
          isSlashing = false
        })

        wait(SLASH_DURATION + 0.1, () => {
          slashCooldown = 0
        })
      }

      onKeyPress("x", performSlash)
      onKeyPress("j", performSlash)

      // === AURA PARTICLES & BREATHING ===
      onUpdate(() => {
        auraTimer -= dt()
        if (auraTimer <= 0 && !isDashing) {
          spawnAuraParticle(vec2(player.pos.x, player.pos.y - 32))
          auraTimer = 0.15
        }

        if (!isDashing && !isSlashing) {
          const pulse = 1 + Math.sin(time() * 1.5) * 0.03
          player.scale.x = facingDir * pulse
          player.scale.y = pulse
        }
      })

      // === SISTER SIGNAL PULSE ===
      // responds to depth (closer = brighter) and signal (connection strength)
      sisterSignal.onUpdate(() => {
        // base brightness increases with depth (approaching sister)
        const depthBonus = Math.min(depth / 20, 1) * 0.3  // up to +0.3 at depth 20
        // signal connection affects visibility
        const signalStrength = signal / playerStats.maxSignal
        const connectionMult = 0.3 + signalStrength * 0.7  // 0.3 to 1.0

        // base pulse
        const pulse = (0.3 + depthBonus + Math.sin(time() * 1.5) * 0.4) * connectionMult

        // size grows slightly as you get closer
        const sizeBonus = 1 + (depth / 20) * 0.5  // up to 1.5x at depth 20

        sisterSignal.opacity = Math.max(0.1, pulse)
        sisterSignal.scale = vec2(sizeBonus * (1 + Math.sin(time() * 1.5) * 0.2))

        // flicker when signal is very low
        if (signal < 2) {
          sisterSignal.opacity *= Math.random() > 0.3 ? 1 : 0.2
        }
      })

      // === FALL DEATH ===
      player.onUpdate(() => {
        // don't trigger during room transition or if already dead
        if (transitioning || isDead) return
        if (player.pos.y > height() + 100) {
          isDead = true
          console.log("[DEATH] Fall death - player.y:", player.pos.y, "health:", health, "depth:", depth, "transitioning:", transitioning)
          go("feverDream", { depth, score })
        }
      })

      onKeyPress("r", () => go("game"))
      onKeyPress("escape", () => go("menu"))
    })

    // ============================================
    // FEVER DREAM SCENE (Phase 2)
    // ============================================
    scene("feverDream", ({ depth, score }) => {
      console.log("[FEVER DREAM] Entered - depth:", depth, "score:", score, "totalRuns:", saveData.totalRuns)

      const dreamType = checkFeverDream()
      console.log("[FEVER DREAM] dreamType:", dreamType)

      // no dream - go straight to gameover
      if (!dreamType) {
        console.log("[FEVER DREAM] No dream, going to gameover")
        go("gameover", { depth, score })
        return
      }

      // black background
      add([rect(width(), height()), pos(0, 0), color(0, 0, 0), z(0)])

      // create converging particles
      const particles = []
      const particleCount = 30
      const centerX = center().x
      const centerY = center().y

      for (let i = 0; i < particleCount; i++) {
        // start from edges
        const angle = (i / particleCount) * Math.PI * 2
        const dist = rand(300, 400)
        const startX = centerX + Math.cos(angle) * dist
        const startY = centerY + Math.sin(angle) * dist

        const p = add([
          circle(rand(2, 4)),
          pos(startX, startY),
          color(255, 0, 64),
          opacity(0),
          anchor("center"),
          z(1),
          {
            startX,
            startY,
            delay: rand(0, 0.5),
            speed: rand(0.3, 0.6),
          },
        ])
        particles.push(p)
      }

      let elapsed = 0
      let phase = 0  // 0: particles converge, 1: flash + text, 2: stat text, 3: fade out
      let statText = ""

      // main text elements (hidden initially)
      const mainText = add([
        text("", { size: 24 }),
        pos(centerX, centerY - 20),
        anchor("center"),
        color(255, 0, 64),
        opacity(0),
        z(10),
      ])

      const subText = add([
        text("", { size: 20 }),
        pos(centerX, centerY + 20),
        anchor("center"),
        color(hexToRgb(PALETTE.upgrade)),
        opacity(0),
        z(10),
      ])

      // center glow
      const glow = add([
        circle(20),
        pos(centerX, centerY),
        color(255, 0, 64),
        opacity(0),
        anchor("center"),
        z(5),
      ])

      onUpdate(() => {
        elapsed += dt()

        // phase 0: particles converge (0 - 1.5s)
        if (phase === 0) {
          particles.forEach(p => {
            if (elapsed > p.delay) {
              const t = Math.min(1, (elapsed - p.delay) * p.speed)
              p.pos.x = lerp(p.startX, centerX, t)
              p.pos.y = lerp(p.startY, centerY, t)
              p.opacity = Math.min(0.8, t * 1.5)

              // particles get smaller as they converge
              const size = lerp(1, 0.3, t)
              p.scale = vec2(size)
            }
          })

          // glow grows
          glow.opacity = Math.min(0.4, elapsed * 0.3)
          glow.scale = vec2(1 + elapsed * 0.5)

          if (elapsed > 1.5) {
            phase = 1
            // flash
            flash(Color.fromArray([255, 0, 64]), 0.15)
            // apply stat echo
            if (dreamType === 'statEcho') {
              statText = applyStatEcho()
            }
            mainText.text = "The spectrum remembers."
            mainText.opacity = 1
          }
        }

        // phase 1: show main text (1.5 - 2.5s)
        if (phase === 1 && elapsed > 2.5) {
          phase = 2
          subText.text = statText
          subText.opacity = 1
        }

        // phase 2: show stat text (2.5 - 4s)
        if (phase === 2 && elapsed > 4) {
          phase = 3
        }

        // phase 3: fade out and go to gameover
        if (phase === 3) {
          mainText.opacity -= dt() * 2
          subText.opacity -= dt() * 2
          glow.opacity -= dt() * 2
          particles.forEach(p => { p.opacity -= dt() * 2 })

          if (mainText.opacity <= 0) {
            go("gameover", { depth, score })
          }
        }
      })

      // allow skip after main reveal
      onKeyPress("space", () => {
        if (phase >= 1) {
          go("gameover", { depth, score })
        }
      })
    })

    // ============================================
    // GAME OVER SCENE
    // ============================================
    scene("gameover", ({ depth, score }) => {
      console.log("[GAMEOVER] Entered - depth:", depth, "score:", score)

      add([sprite("bg"), pos(0, 0), z(Z.BG)])

      // process run end and get echo
      const { isNewBest, echoBreakdown } = onRunEnd(depth)
      console.log("[GAMEOVER] Echo breakdown:", JSON.stringify(echoBreakdown), "isNewBest:", isNewBest)
      const prevEcho = saveData.echo - echoBreakdown.total

      add([
        text("SIGNAL LOST", { size: 48 }),
        pos(center().x, 100),
        anchor("center"),
        color(255, 0, 64),
      ])

      add([
        text(`Depth reached: ${depth}`, { size: 24 }),
        pos(center().x, 170),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])

      add([
        text(`Score: ${score}`, { size: 20 }),
        pos(center().x, 205),
        anchor("center"),
        color(255, 200, 50),
      ])

      // echo earned box
      const boxY = 270
      add([
        rect(200, 90, { radius: 4 }),
        pos(center().x, boxY),
        anchor("center"),
        color(30, 30, 50),
        outline(2, Color.fromArray(hexToRgb(PALETTE.aura))),
      ])

      add([
        text(`+${echoBreakdown.base} Echo collected`, { size: 18 }),
        pos(center().x, boxY - 25),
        anchor("center"),
        color(hexToRgb(PALETTE.upgrade)),
      ])

      if (echoBreakdown.newBest > 0) {
        add([
          text(`+${echoBreakdown.newBest} new depth bonus`, { size: 14 }),
          pos(center().x, boxY),
          anchor("center"),
          color(255, 215, 0),
        ])
      }

      add([
        text(`+${echoBreakdown.total} total`, { size: 16 }),
        pos(center().x, boxY + 25),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])

      // total echo display - make it clear it's saved
      add([
        text(`Your Echo: ${saveData.echo}`, { size: 20 }),
        pos(center().x, 340),
        anchor("center"),
        color(hexToRgb(PALETTE.upgrade)),
      ])
      add([
        text("(saved)", { size: 12 }),
        pos(center().x, 360),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      // high score display
      if (isNewBest) {
        add([
          text("NEW RECORD!", { size: 18 }),
          pos(center().x, 395),
          anchor("center"),
          color(255, 215, 0),
        ])
      } else {
        add([
          text(`Best: ${saveData.bestDepth}`, { size: 16 }),
          pos(center().x, 395),
          anchor("center"),
          color(hexToRgb(PALETTE.textDim)),
        ])
      }

      add([
        text("She's still waiting.", { size: 14 }),
        pos(center().x, 440),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      add([
        text("R to retry | ESC for menu", { size: 18 }),
        pos(center().x, 500),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])

      onKeyPress("r", () => go("game"))
      onKeyPress("escape", () => go("menu"))
    })

    // start with intro or menu based on run count
    if (shouldShowIntro()) {
      go("intro")
    } else {
      go("menu")
    }
  </script>
</body>
</html>

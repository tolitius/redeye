<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>REDEYE</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a15;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      border-radius: 4px;
      box-shadow: 0 0 40px rgba(255, 0, 64, 0.15);
    }
  </style>
</head>
<body>
  <script src="https://unpkg.com/kaplay@3001/dist/kaplay.js"></script>
  <script>
    // ============================================
    // REDEYE - A Sidescroller Roguelike
    // Phase 1: Core Feel (with animated character)
    // ============================================

    // === NEON PALETTE (from design spec) ===
    const PALETTE = {
      bg: "#0f0f23",
      bgLight: "#1a1a3e",
      bgAccent: "#2a2a5e",
      body: "#1a1a2e",
      eyes: "#ff0040",
      aura: "#ff0040",
      blade: "#ff0040",
      bladeTrail: "#ff6680",
      enemy: "#cccccc",
      enemyFlicker: "#ffffff",
      health: "#4ade80",
      signalBoost: "#60a5fa",
      upgrade: "#fbbf24",
      text: "#ffffff",
      textDim: "#8080a0",
      healthFull: "#ff0040",
      healthEmpty: "#4a4a4a",
      signalBar: "#ff0040",
      signalEmpty: "#2a2a2a",
      platform: "#464666",
      platformDark: "#2a2a4a",
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [0, 0, 0]
    }

    // === GAME CONSTANTS ===
    const SPEED = 300
    const JUMP_FORCE = 550
    const GRAVITY_RISE = 1400
    const GRAVITY_FALL = 1800
    const MAX_FALL_SPEED = 600

    const DASH_DISTANCE = 128
    const DASH_DURATION = 0.15
    const DASH_SPEED = DASH_DISTANCE / DASH_DURATION

    const SIGNAL_MAX = 10
    const SIGNAL_REGEN_RIGHT = 1.5
    const SIGNAL_DRAIN_STILL = 0.5
    const SIGNAL_DRAIN_LEFT = 1.5
    const SLASH_COST = 1
    const DASH_COST = 1

    const SLASH_DURATION = 0.2
    const SLASH_RANGE = 48
    const SLASH_DAMAGE = 1

    const Z = {
      BG: -100,
      BG_PARTICLES: -50,
      PLATFORMS: 0,
      PICKUPS: 10,
      ENEMIES: 20,
      PLAYER_LEGS: 28,
      PLAYER: 30,
      PLAYER_ARM: 32,
      SLASH: 35,
      PARTICLES: 50,
      HUD: 100,
    }

    // ============================================
    // PROCEDURAL SPRITE GENERATORS
    // ============================================

    function makeGradientBg(w = 800, h = 600) {
      const c = document.createElement("canvas")
      c.width = w; c.height = h
      const ctx = c.getContext("2d")

      const grad = ctx.createLinearGradient(0, 0, 0, h)
      grad.addColorStop(0, PALETTE.bgLight)
      grad.addColorStop(0.5, PALETTE.bg)
      grad.addColorStop(1, "#0a0a15")
      ctx.fillStyle = grad
      ctx.fillRect(0, 0, w, h)

      for (let i = 0; i < 60; i++) {
        const x = Math.random() * w
        const y = Math.random() * h * 0.8
        const r = Math.random() * 1.5 + 0.5
        const isRed = Math.random() < 0.15
        ctx.fillStyle = isRed ? "rgba(255,0,64,0.3)" : `rgba(255,255,255,${0.1 + Math.random() * 0.15})`
        ctx.beginPath()
        ctx.arc(x, y, r, 0, Math.PI * 2)
        ctx.fill()
      }

      return c.toDataURL()
    }

    // redeye sprite - full cloaked figure with glowing eyes
    function makeRedeyeBodySprite(size = 64) {
      const c = document.createElement("canvas")
      c.width = size
      c.height = size
      const ctx = c.getContext("2d")

      const cx = size / 2
      const cy = size * 0.45

      // red aura glow
      const auraGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.55)
      auraGrad.addColorStop(0, "rgba(255,0,64,0.25)")
      auraGrad.addColorStop(0.5, "rgba(255,0,64,0.1)")
      auraGrad.addColorStop(1, "transparent")
      ctx.fillStyle = auraGrad
      ctx.fillRect(0, 0, c.width, c.height)

      // full cloak body - tall flowing robe (slimmer)
      const bodyGrad = ctx.createLinearGradient(cx - size*0.25, 0, cx + size*0.25, size)
      bodyGrad.addColorStop(0, "#2a2a3e")
      bodyGrad.addColorStop(0.3, PALETTE.body)
      bodyGrad.addColorStop(1, "#0a0a15")

      ctx.fillStyle = bodyGrad
      ctx.beginPath()
      ctx.moveTo(cx, size * 0.05)  // top of hood
      ctx.quadraticCurveTo(cx + size * 0.32, size * 0.1, cx + size * 0.36, size * 0.35)
      ctx.quadraticCurveTo(cx + size * 0.34, size * 0.6, cx + size * 0.28, size * 0.95)
      ctx.lineTo(cx - size * 0.28, size * 0.95)
      ctx.quadraticCurveTo(cx - size * 0.34, size * 0.6, cx - size * 0.36, size * 0.35)
      ctx.quadraticCurveTo(cx - size * 0.32, size * 0.1, cx, size * 0.05)
      ctx.closePath()
      ctx.fill()

      // cloak bottom tattered edge
      ctx.fillStyle = "#0a0a15"
      ctx.beginPath()
      ctx.moveTo(cx - size * 0.28, size * 0.95)
      ctx.lineTo(cx - size * 0.24, size * 0.88)
      ctx.lineTo(cx - size * 0.12, size * 0.95)
      ctx.lineTo(cx, size * 0.9)
      ctx.lineTo(cx + size * 0.12, size * 0.95)
      ctx.lineTo(cx + size * 0.24, size * 0.88)
      ctx.lineTo(cx + size * 0.28, size * 0.95)
      ctx.closePath()
      ctx.fill()

      // edge highlight
      ctx.strokeStyle = "rgba(255,255,255,0.1)"
      ctx.lineWidth = 1
      ctx.beginPath()
      ctx.moveTo(cx, size * 0.05)
      ctx.quadraticCurveTo(cx - size * 0.32, size * 0.1, cx - size * 0.36, size * 0.35)
      ctx.stroke()

      // glowing red eyes
      const eyeY = size * 0.28
      const eyeSpacing = size * 0.12
      const eyeSize = size * 0.055

      for (let i = 0; i < 2; i++) {
        const ex = cx + (i === 0 ? -eyeSpacing : eyeSpacing)
        const eyeGlow = ctx.createRadialGradient(ex, eyeY, 0, ex, eyeY, eyeSize * 4)
        eyeGlow.addColorStop(0, "rgba(255,0,64,0.9)")
        eyeGlow.addColorStop(0.3, "rgba(255,0,64,0.4)")
        eyeGlow.addColorStop(1, "transparent")
        ctx.fillStyle = eyeGlow
        ctx.fillRect(ex - eyeSize*5, eyeY - eyeSize*5, eyeSize*10, eyeSize*10)
      }

      ctx.fillStyle = "#ff0040"
      ctx.shadowColor = "#ff0040"
      ctx.shadowBlur = 12
      ctx.beginPath()
      ctx.arc(cx - eyeSpacing, eyeY, eyeSize, 0, Math.PI * 2)
      ctx.arc(cx + eyeSpacing, eyeY, eyeSize, 0, Math.PI * 2)
      ctx.fill()

      ctx.fillStyle = "#ff8080"
      ctx.shadowBlur = 6
      ctx.beginPath()
      ctx.arc(cx - eyeSpacing, eyeY, eyeSize * 0.4, 0, Math.PI * 2)
      ctx.arc(cx + eyeSpacing, eyeY, eyeSize * 0.4, 0, Math.PI * 2)
      ctx.fill()
      ctx.shadowBlur = 0

      return c.toDataURL()
    }

    // sword blade sprite - large glowing blade
    function makeSwordArmSprite(size = 70) {
      const c = document.createElement("canvas")
      c.width = size
      c.height = size * 0.25
      const ctx = c.getContext("2d")

      // outer glow
      ctx.shadowColor = "#ff0040"
      ctx.shadowBlur = 25

      // blade body - thick glowing line
      const bladeGrad = ctx.createLinearGradient(0, c.height/2, c.width, c.height/2)
      bladeGrad.addColorStop(0, "#ff0040")
      bladeGrad.addColorStop(0.6, "#ff4466")
      bladeGrad.addColorStop(1, "#ffffff")

      ctx.strokeStyle = bladeGrad
      ctx.lineWidth = c.height * 0.6
      ctx.lineCap = "round"
      ctx.beginPath()
      ctx.moveTo(8, c.height/2)
      ctx.lineTo(c.width - 4, c.height/2)
      ctx.stroke()

      // bright core
      ctx.shadowBlur = 15
      ctx.strokeStyle = "#ffcccc"
      ctx.lineWidth = c.height * 0.25
      ctx.beginPath()
      ctx.moveTo(10, c.height/2)
      ctx.lineTo(c.width - 6, c.height/2)
      ctx.stroke()

      ctx.shadowBlur = 0

      return c.toDataURL()
    }

    // slash arc effect
    function makeSlashArcSprite(size = 80) {
      const c = document.createElement("canvas")
      c.width = size * 1.2
      c.height = size
      const ctx = c.getContext("2d")

      const cx = size * 0.2
      const cy = size / 2

      // outer glow
      ctx.strokeStyle = "rgba(255,0,64,0.3)"
      ctx.lineWidth = 20
      ctx.lineCap = "round"
      ctx.beginPath()
      ctx.arc(cx, cy, size * 0.45, -Math.PI * 0.5, Math.PI * 0.5)
      ctx.stroke()

      // main arc
      ctx.strokeStyle = "#ff0040"
      ctx.lineWidth = 6
      ctx.shadowColor = "#ff0040"
      ctx.shadowBlur = 20
      ctx.beginPath()
      ctx.arc(cx, cy, size * 0.45, -Math.PI * 0.5, Math.PI * 0.5)
      ctx.stroke()

      // bright core
      ctx.strokeStyle = "#ff9999"
      ctx.lineWidth = 2
      ctx.shadowBlur = 10
      ctx.beginPath()
      ctx.arc(cx, cy, size * 0.45, -Math.PI * 0.45, Math.PI * 0.45)
      ctx.stroke()

      ctx.shadowBlur = 0

      return c.toDataURL()
    }

    function makePlatformSprite(w = 160, h = 24) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")
      const r = 4

      const grad = ctx.createLinearGradient(0, 0, 0, h)
      grad.addColorStop(0, PALETTE.platform)
      grad.addColorStop(1, PALETTE.platformDark)
      ctx.fillStyle = grad
      ctx.beginPath()
      ctx.roundRect(0, 0, w, h, r)
      ctx.fill()

      ctx.fillStyle = "rgba(255,255,255,0.08)"
      ctx.fillRect(r, 1, w - r*2, 2)

      ctx.strokeStyle = "rgba(255,0,64,0.15)"
      ctx.lineWidth = 1
      ctx.beginPath()
      ctx.roundRect(0.5, 0.5, w-1, h-1, r)
      ctx.stroke()

      return c.toDataURL()
    }

    function makeGroundSprite(w = 800, h = 48) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      const grad = ctx.createLinearGradient(0, 0, 0, h)
      grad.addColorStop(0, PALETTE.platform)
      grad.addColorStop(0.3, PALETTE.platformDark)
      grad.addColorStop(1, "#1a1a2a")
      ctx.fillStyle = grad
      ctx.fillRect(0, 0, w, h)

      ctx.fillStyle = "rgba(255,255,255,0.06)"
      ctx.fillRect(0, 0, w, 2)

      ctx.strokeStyle = "rgba(0,0,0,0.1)"
      for (let x = 40; x < w; x += 60) {
        ctx.beginPath()
        ctx.moveTo(x, 4)
        ctx.lineTo(x, h - 2)
        ctx.stroke()
      }

      return c.toDataURL()
    }

    // crawler enemy sprite - low wide rectangle with static effect
    function makeCrawlerSprite(w = 28, h = 20) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // base body - white/grey
      const bodyGrad = ctx.createLinearGradient(0, 0, 0, h)
      bodyGrad.addColorStop(0, "#dddddd")
      bodyGrad.addColorStop(0.5, "#aaaaaa")
      bodyGrad.addColorStop(1, "#888888")
      ctx.fillStyle = bodyGrad

      // rounded rectangle body
      ctx.beginPath()
      ctx.roundRect(2, 4, w - 4, h - 6, 4)
      ctx.fill()

      // static noise overlay
      ctx.fillStyle = "rgba(255,255,255,0.3)"
      for (let i = 0; i < 15; i++) {
        const nx = Math.random() * (w - 6) + 3
        const ny = Math.random() * (h - 8) + 5
        ctx.fillRect(nx, ny, 2, 2)
      }

      // dark spots (no eyes - key visual distinction)
      ctx.fillStyle = "rgba(0,0,0,0.2)"
      ctx.fillRect(6, 8, 4, 4)
      ctx.fillRect(w - 10, 8, 4, 4)

      // small legs
      ctx.fillStyle = "#666666"
      for (let i = 0; i < 4; i++) {
        const lx = 5 + i * 6
        ctx.fillRect(lx, h - 4, 2, 4)
      }

      return c.toDataURL()
    }

    // spitter enemy sprite - vertical blob with mouth
    function makeSpitterSprite(w = 24, h = 36) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // body - vertical blob shape
      const bodyGrad = ctx.createLinearGradient(0, 0, 0, h)
      bodyGrad.addColorStop(0, "#cccccc")
      bodyGrad.addColorStop(0.5, "#999999")
      bodyGrad.addColorStop(1, "#666666")
      ctx.fillStyle = bodyGrad

      // blob body
      ctx.beginPath()
      ctx.ellipse(w/2, h/2 + 4, w/2 - 2, h/2 - 2, 0, 0, Math.PI * 2)
      ctx.fill()

      // mouth opening (dark hole)
      ctx.fillStyle = "#222222"
      ctx.beginPath()
      ctx.ellipse(w/2, 10, 6, 4, 0, 0, Math.PI * 2)
      ctx.fill()

      // static noise
      ctx.fillStyle = "rgba(255,255,255,0.25)"
      for (let i = 0; i < 12; i++) {
        const nx = Math.random() * (w - 8) + 4
        const ny = Math.random() * (h - 10) + 8
        ctx.fillRect(nx, ny, 2, 2)
      }

      return c.toDataURL()
    }

    // spitter projectile sprite
    function makeProjectileSprite(size = 8) {
      const c = document.createElement("canvas")
      c.width = size
      c.height = size
      const ctx = c.getContext("2d")

      // white orb with glow
      ctx.shadowColor = "#ffffff"
      ctx.shadowBlur = 4
      ctx.fillStyle = "#ffffff"
      ctx.beginPath()
      ctx.arc(size/2, size/2, size/2 - 1, 0, Math.PI * 2)
      ctx.fill()

      // inner static
      ctx.fillStyle = "rgba(200,200,200,0.5)"
      ctx.fillRect(size/2 - 1, size/2 - 1, 2, 2)

      return c.toDataURL()
    }

    // rusher enemy sprite - wide, low, aggressive shape
    function makeRusherSprite(w = 40, h = 18) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // body gradient - slightly darker than crawler
      const bodyGrad = ctx.createLinearGradient(0, 0, 0, h)
      bodyGrad.addColorStop(0, "#bbbbbb")
      bodyGrad.addColorStop(0.5, "#888888")
      bodyGrad.addColorStop(1, "#555555")
      ctx.fillStyle = bodyGrad

      // wedge/arrow shape pointing right
      ctx.beginPath()
      ctx.moveTo(w - 4, h / 2)        // point
      ctx.lineTo(4, 2)                 // top back
      ctx.lineTo(4, h - 2)             // bottom back
      ctx.closePath()
      ctx.fill()

      // speed lines on back
      ctx.strokeStyle = "rgba(255,255,255,0.3)"
      ctx.lineWidth = 1
      for (let i = 0; i < 3; i++) {
        const y = 5 + i * 4
        ctx.beginPath()
        ctx.moveTo(2, y)
        ctx.lineTo(10, y)
        ctx.stroke()
      }

      // static noise
      ctx.fillStyle = "rgba(255,255,255,0.2)"
      for (let i = 0; i < 8; i++) {
        const nx = 8 + Math.random() * (w - 16)
        const ny = 4 + Math.random() * (h - 8)
        ctx.fillRect(nx, ny, 2, 2)
      }

      return c.toDataURL()
    }

    function makeDrifterSprite(r = 16) {
      const size = r * 2 + 4
      const c = document.createElement("canvas")
      c.width = size
      c.height = size
      const ctx = c.getContext("2d")
      const cx = size / 2
      const cy = size / 2

      // outer glow
      const glowGrad = ctx.createRadialGradient(cx, cy, r * 0.3, cx, cy, r)
      glowGrad.addColorStop(0, "rgba(200, 180, 255, 0.9)")
      glowGrad.addColorStop(0.5, "rgba(150, 120, 200, 0.5)")
      glowGrad.addColorStop(1, "rgba(100, 80, 150, 0)")
      ctx.fillStyle = glowGrad
      ctx.beginPath()
      ctx.arc(cx, cy, r, 0, Math.PI * 2)
      ctx.fill()

      // core
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)"
      ctx.beginPath()
      ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2)
      ctx.fill()

      // static specks
      ctx.fillStyle = "rgba(255,255,255,0.4)"
      for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2
        const dist = r * 0.4 + Math.random() * r * 0.4
        ctx.fillRect(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, 2, 2)
      }

      return c.toDataURL()
    }

    function makePillarSprite(w = 24, h = 48) {
      const c = document.createElement("canvas")
      c.width = w
      c.height = h
      const ctx = c.getContext("2d")

      // body gradient - dark metallic
      const bodyGrad = ctx.createLinearGradient(0, 0, w, 0)
      bodyGrad.addColorStop(0, "#444444")
      bodyGrad.addColorStop(0.3, "#666666")
      bodyGrad.addColorStop(0.7, "#555555")
      bodyGrad.addColorStop(1, "#333333")
      ctx.fillStyle = bodyGrad
      ctx.fillRect(2, 4, w - 4, h - 4)

      // top cap
      ctx.fillStyle = "#777777"
      ctx.fillRect(0, 0, w, 6)

      // horizontal bands
      ctx.fillStyle = "#555555"
      ctx.fillRect(0, h * 0.33, w, 3)
      ctx.fillRect(0, h * 0.66, w, 3)

      // static glitch lines
      ctx.fillStyle = "rgba(255,255,255,0.3)"
      for (let i = 0; i < 6; i++) {
        const y = 8 + Math.random() * (h - 16)
        const lw = 4 + Math.random() * 8
        ctx.fillRect(4 + Math.random() * (w - 12), y, lw, 2)
      }

      return c.toDataURL()
    }

    // static death particles for enemies
    function spawnStaticBurst(p) {
      for (let i = 0; i < 15; i++) {
        add([
          rect(rand(3, 8), rand(3, 8)),
          pos(p.x + rand(-10, 10), p.y + rand(-10, 10)),
          color(rand(180, 255), rand(180, 255), rand(180, 255)),
          opacity(1),
          move(rand(0, 360), rand(80, 200)),
          lifespan(rand(0.2, 0.5), { fade: 0.15 }),
          rotate(rand(0, 360)),
          z(Z.PARTICLES),
        ])
      }
    }

    // health drop from enemies (called from game scene)
    const HEALTH_DROP_CHANCE = 0.25  // 25% chance

    // ============================================
    // EFFECT HELPERS
    // ============================================

    function spawnAuraParticle(p) {
      add([
        circle(rand(2, 4)),
        pos(p.x + rand(-8, 8), p.y + rand(-5, 15)),
        color(255, 0, 64),
        opacity(rand(0.3, 0.6)),
        move(90, rand(20, 50)),
        lifespan(rand(0.3, 0.6), { fade: 0.2 }),
        scale(1),
        z(Z.PARTICLES - 5),
      ])
    }

    function slashBurst(p, facing) {
      const baseAngle = facing > 0 ? 0 : 180
      for (let i = 0; i < 12; i++) {
        add([
          circle(rand(2, 6)),
          pos(p.x + facing * 30, p.y),
          color(255, rand(0, 100), rand(64, 128)),
          opacity(1),
          move(baseAngle + rand(-60, 60), rand(100, 250)),
          lifespan(0.3, { fade: 0.2 }),
          scale(1),
          z(Z.PARTICLES),
        ])
      }
    }

    function spawnAfterimage(obj) {
      const img = add([
        sprite("redeye"),
        pos(obj.pos.x, obj.pos.y),
        anchor("bot"),
        scale(obj.scale.x, obj.scale.y),
        opacity(0.4),
        z(Z.PLAYER - 1),
      ])
      img.onUpdate(() => {
        img.opacity -= dt() * 3
        if (img.opacity <= 0) destroy(img)
      })
    }

    function spawnAmbientParticle() {
      const isRed = Math.random() < 0.2
      add([
        circle(rand(0.5, 2)),
        pos(rand(0, width()), height() + 10),
        color(isRed ? 255 : 200, isRed ? 0 : 200, isRed ? 64 : 220),
        opacity(rand(0.05, 0.15)),
        move(rand(80, 100), rand(10, 30)),
        lifespan(rand(6, 12), { fade: 3 }),
        scale(1),
        z(Z.BG_PARTICLES),
      ])
    }

    function floatingText(p, txt, col) {
      const ft = add([
        text(txt, { size: 16 }),
        pos(p.x, p.y - 10),
        anchor("center"),
        color(col[0], col[1], col[2]),
        opacity(1),
        z(Z.PARTICLES + 10),
      ])
      ft.onUpdate(() => {
        ft.pos.y -= 50 * dt()
        ft.opacity -= 1.2 * dt()
        if (ft.opacity <= 0) destroy(ft)
      })
    }

    // ============================================
    // GAME INITIALIZATION
    // ============================================
    kaplay({
      width: 800,
      height: 600,
      background: hexToRgb(PALETTE.bg),
      scale: 1,
      debug: true,
    })

    // load sprites
    loadSprite("bg", makeGradientBg())
    loadSprite("redeye", makeRedeyeBodySprite(64))
    loadSprite("sword-arm", makeSwordArmSprite(50))
    loadSprite("slash-arc", makeSlashArcSprite(80))
    loadSprite("platform-sm", makePlatformSprite(100, 20))
    loadSprite("platform-md", makePlatformSprite(160, 24))
    loadSprite("platform-lg", makePlatformSprite(240, 24))
    loadSprite("ground", makeGroundSprite(800, 48))
    loadSprite("crawler", makeCrawlerSprite(28, 20))
    loadSprite("spitter", makeSpitterSprite(24, 36))
    loadSprite("projectile", makeProjectileSprite(8))
    loadSprite("rusher", makeRusherSprite(40, 18))
    loadSprite("drifter", makeDrifterSprite(16))
    loadSprite("pillar", makePillarSprite(24, 48))

    // ============================================
    // MENU SCENE
    // ============================================
    scene("menu", () => {
      add([sprite("bg"), pos(0, 0), z(Z.BG)])
      loop(0.3, spawnAmbientParticle)

      add([
        text("REDEYE", { size: 64 }),
        pos(center().x, 140),
        anchor("center"),
        color(255, 0, 64),
      ])

      add([
        text("Follow the Signal", { size: 20 }),
        pos(center().x, 200),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      add([
        text("Your sister has been taken.", { size: 16 }),
        pos(center().x, 300),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])
      add([
        text("Her signal calls from the depths.", { size: 16 }),
        pos(center().x, 325),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      add([
        text("Press SPACE to begin", { size: 24 }),
        pos(center().x, 420),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])

      add([
        text("Arrow keys: Move | Space: Jump | Shift: Dash | X: Slash", { size: 14 }),
        pos(center().x, 520),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      const sig = add([
        circle(6),
        pos(width() - 40, 40),
        color(255, 0, 64),
        opacity(1),
        anchor("center"),
      ])
      sig.onUpdate(() => {
        sig.opacity = 0.5 + Math.sin(time() * 2) * 0.5
        sig.scale = vec2(1 + Math.sin(time() * 2) * 0.2)
      })

      onKeyPress("space", () => go("game"))
    })

    // ============================================
    // MAIN GAME SCENE
    // ============================================
    scene("game", () => {
      let signal = SIGNAL_MAX
      let health = 5
      let facingDir = 1
      let isSlashing = false
      let slashCooldown = 0
      let isDashing = false
      let dashCooldown = 0
      let dashTimer = 0
      let dashDir = 1
      let iFrames = 0
      let auraTimer = 0
      let lastMoveDir = 0
      let walkFrame = 0
      let walkTimer = 0
      let depth = 1
      let transitioning = false
      let inUpgradeRoom = false

      // === PLAYER UPGRADES ===
      const playerStats = {
        maxHealth: 5,
        maxSignal: SIGNAL_MAX,
        slashDamage: 1,
        moveSpeed: SPEED,
        dashDistance: DASH_DISTANCE,
        signalRegen: 1.0,  // multiplier
      }

      const UPGRADES = [
        { id: "health1", name: "Vitality", desc: "+2 Max Health", apply: () => { playerStats.maxHealth += 2; health = Math.min(health + 2, playerStats.maxHealth) } },
        { id: "health2", name: "Resilience", desc: "+1 Max Health", apply: () => { playerStats.maxHealth += 1; health = Math.min(health + 1, playerStats.maxHealth) } },
        { id: "signal1", name: "Attunement", desc: "+3 Max Signal", apply: () => { playerStats.maxSignal += 3 } },
        { id: "signal2", name: "Flow", desc: "+50% Signal Regen", apply: () => { playerStats.signalRegen *= 1.5 } },
        { id: "damage1", name: "Sharp Edge", desc: "+1 Slash Damage", apply: () => { playerStats.slashDamage += 1 } },
        { id: "speed1", name: "Swift", desc: "+20% Move Speed", apply: () => { playerStats.moveSpeed *= 1.2 } },
        { id: "dash1", name: "Long Dash", desc: "+50% Dash Distance", apply: () => { playerStats.dashDistance *= 1.5 } },
        { id: "heal1", name: "Second Wind", desc: "Restore 3 Health", apply: () => { health = Math.min(health + 3, playerStats.maxHealth) } },
      ]

      let appliedUpgrades = []

      add([sprite("bg"), pos(0, 0), z(Z.BG)])
      loop(0.25, spawnAmbientParticle)

      // === GROUND (solid, not one-way) ===
      add([
        sprite("ground"),
        pos(0, height() - 48),
        area(),
        body({ isStatic: true }),
        z(Z.PLATFORMS),
        "ground",
      ])

      // === PLATFORMS (one-way) ===
      function addOneWayPlatform(spr, x, y) {
        return add([
          sprite(spr),
          pos(x, y),
          area(),
          body({ isStatic: true }),
          z(Z.PLATFORMS),
          "platform",
          "oneWay",
        ])
      }

      // platform layout patterns
      const ROOM_PATTERNS = [
        // pattern 0: staircase right
        [["lg", 80, 450], ["md", 350, 380], ["sm", 550, 300]],
        // pattern 1: staircase left
        [["sm", 100, 300], ["md", 280, 380], ["lg", 480, 450]],
        // pattern 2: two levels
        [["lg", 100, 450], ["lg", 500, 450], ["md", 300, 300]],
        // pattern 3: scattered
        [["sm", 150, 400], ["sm", 400, 350], ["sm", 600, 400], ["md", 280, 250]],
        // pattern 4: high path
        [["md", 80, 350], ["sm", 300, 280], ["md", 500, 350]],
      ]

      function generateRoom() {
        // clear existing platforms, enemies, projectiles, and upgrade UI
        get("platform").forEach(destroy)
        get("enemy").forEach(destroy)
        get("projectile").forEach(destroy)
        get("upgradeUI").forEach(destroy)

        // pick random pattern
        const pattern = ROOM_PATTERNS[Math.floor(Math.random() * ROOM_PATTERNS.length)]

        // create platforms
        pattern.forEach(([size, x, y]) => {
          const spr = size === "lg" ? "platform-lg" : size === "md" ? "platform-md" : "platform-sm"
          addOneWayPlatform(spr, x, y)
        })

        // spawn enemies based on depth (gentler early ramp)
        const crawlerCount = Math.min(1 + Math.floor(depth / 2), 4)  // 1, 1, 2, 2, 3, 3, 4...
        const spitterCount = depth >= 3 ? Math.min(Math.floor((depth - 2) / 2), 2) : 0  // 0, 0, 0, 1, 1, 2...
        const rusherCount = depth >= 4 ? Math.min(Math.floor((depth - 3) / 3), 2) : 0  // 0, 0, 0, 0, 1, 1, 1, 2...
        const drifterCount = depth >= 6 ? Math.min(Math.floor((depth - 5) / 3), 2) : 0  // after first upgrade
        const pillarCount = depth >= 7 ? Math.min(Math.floor((depth - 6) / 4), 2) : 0  // tanks at depth 7+

        // spawn crawlers
        for (let i = 0; i < crawlerCount; i++) {
          const spawnX = 400 + Math.random() * 350
          const spawnY = 300 + Math.random() * 150
          wait(0.5 + i * 0.5, () => spawnCrawler(spawnX, spawnY))
        }

        // spawn spitters (elevated positions)
        for (let i = 0; i < spitterCount; i++) {
          const spawnX = 500 + Math.random() * 250
          const spawnY = 250 + Math.random() * 100
          wait(1 + i * 1, () => spawnSpitter(spawnX, spawnY))
        }

        // spawn rushers (ground level - they charge horizontally)
        for (let i = 0; i < rusherCount; i++) {
          const spawnX = 550 + Math.random() * 200
          wait(1.5 + i * 1.5, () => spawnRusher(spawnX, height() - 48))
        }

        // spawn drifters (floating in air)
        for (let i = 0; i < drifterCount; i++) {
          const spawnX = 450 + Math.random() * 300
          const spawnY = 150 + Math.random() * 150  // upper area
          wait(2 + i * 1, () => spawnDrifter(spawnX, spawnY))
        }

        // spawn pillars (ground level tanks)
        for (let i = 0; i < pillarCount; i++) {
          const spawnX = 500 + Math.random() * 250
          wait(2.5 + i * 2, () => spawnPillar(spawnX, height() - 48))
        }
      }

      // generate initial room
      generateRoom()

      // === PLAYER ===
      const player = add([
        sprite("redeye"),
        pos(100, 400),
        area(),
        body(),
        anchor("bot"),
        scale(1),
        z(Z.PLAYER),
        "player",
        {
          canDoubleJump: false,
          hasJumped: false,
          wasGrounded: true,
        }
      ])

      // sword arm (hidden by default)
      const swordArm = add([
        sprite("sword-arm"),
        pos(0, 0),
        anchor("left"),  // pivot from hilt
        scale(1),
        opacity(0),
        z(Z.SLASH),
      ])

      setGravity(GRAVITY_RISE)

      // === ONE-WAY PLATFORM LOGIC ===
      player.onBeforePhysicsResolve((collision) => {
        // only affect platforms tagged "oneWay"
        if (!collision.target.is("oneWay")) return

        // pass through when moving up, collide when falling
        if (player.vel.y < 0) {
          collision.preventResolution()
        }
      })

      // === CRAWLER ENEMY SYSTEM ===
      const CRAWLER_SPEED = 120
      let playerInvincible = false
      let invincibleTimer = 0

      function spawnCrawler(x, y) {
        const crawler = add([
          sprite("crawler"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "crawler",
          {
            hp: 1,
          }
        ])

        // AI: move toward player using position directly
        crawler.onUpdate(() => {
          if (!crawler.exists() || !crawler.scale || !player.exists()) return

          // move toward player
          const dir = player.pos.x > crawler.pos.x ? 1 : -1
          crawler.pos.x += CRAWLER_SPEED * dir * dt()
          crawler.scale.x = dir
        })

        // fall death
        crawler.onUpdate(() => {
          if (!crawler.exists()) return
          if (crawler.pos.y > height() + 50) {
            destroy(crawler)
          }
        })

        return crawler
      }

      // === SPITTER ENEMY ===
      const SPITTER_FIRE_RATE = 2.0  // seconds between shots
      const SPITTER_TELEGRAPH = 0.5  // glow before firing
      const PROJECTILE_SPEED = 250

      function spawnSpitter(x, y) {
        const spitter = add([
          sprite("spitter"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "spitter",
          {
            hp: 2,
            fireTimer: SPITTER_FIRE_RATE,
            telegraphing: false,
          }
        ])

        // telegraph glow effect (child object)
        const mouthGlow = add([
          circle(6),
          pos(0, 0),
          color(255, 100, 100),
          opacity(0),
          anchor("center"),
          z(Z.PLATFORMS + 2),
        ])

        spitter.onUpdate(() => {
          if (!spitter.exists() || !player.exists()) {
            if (mouthGlow.exists()) destroy(mouthGlow)
            return
          }

          // update mouth glow position
          mouthGlow.pos = vec2(spitter.pos.x, spitter.pos.y - 26)

          // fire timer
          spitter.fireTimer -= dt()

          // telegraph phase - tilt toward player
          if (spitter.fireTimer <= SPITTER_TELEGRAPH && !spitter.telegraphing) {
            spitter.telegraphing = true
            mouthGlow.opacity = 0.8
            // tilt toward player
            const toPlayer = player.pos.sub(spitter.pos)
            const tiltAngle = Math.atan2(toPlayer.y, toPlayer.x) * (180 / Math.PI) + 90
            spitter.angle = Math.max(-30, Math.min(30, tiltAngle))
          }

          // fire projectile
          if (spitter.fireTimer <= 0) {
            spitter.fireTimer = SPITTER_FIRE_RATE
            spitter.telegraphing = false
            mouthGlow.opacity = 0
            spitter.angle = 0  // reset tilt

            // calculate direction to player
            const dir = player.pos.sub(spitter.pos).unit()
            const mouthPos = vec2(spitter.pos.x, spitter.pos.y - 26)

            // boom effect from mouth
            for (let i = 0; i < 8; i++) {
              add([
                circle(rand(3, 6)),
                pos(mouthPos.x + rand(-5, 5), mouthPos.y + rand(-5, 5)),
                color(255, 255, 255),
                opacity(1),
                move(rand(0, 360), rand(60, 120)),
                lifespan(0.2, { fade: 0.1 }),
                z(Z.PARTICLES),
              ])
            }
            // flash at mouth
            const flash = add([
              circle(12),
              pos(mouthPos),
              color(255, 255, 255),
              opacity(0.9),
              anchor("center"),
              z(Z.PARTICLES),
            ])
            tween(flash.opacity, 0, 0.15, (v) => flash.opacity = v).then(() => destroy(flash))

            // spawn projectile
            const proj = add([
              sprite("projectile"),
              pos(mouthPos),
              area(),
              anchor("center"),
              z(Z.PARTICLES),
              "projectile",
              "enemyProjectile",
            ])

            proj.onUpdate(() => {
              if (!proj.exists()) return
              proj.pos = proj.pos.add(dir.scale(PROJECTILE_SPEED * dt()))

              // destroy if off screen
              if (proj.pos.x < -20 || proj.pos.x > width() + 20 ||
                  proj.pos.y < -20 || proj.pos.y > height() + 20) {
                destroy(proj)
              }
            })

            // projectile damages player
            proj.onCollide("player", () => {
              if (playerInvincible) {
                destroy(proj)
                return
              }
              health -= 1
              healthText.text = "HEALTH: " + "♥".repeat(Math.max(0, health))
              destroy(proj)

              if (health <= 0) {
                go("gameover", depth)
                return
              }

              playerInvincible = true
              invincibleTimer = 1.5
              player.opacity = 0.5
              shake(5)
            })
          }
        })

        // clean up glow on death
        spitter.onDestroy(() => {
          if (mouthGlow.exists()) destroy(mouthGlow)
        })

        // fall death
        spitter.onUpdate(() => {
          if (!spitter.exists()) return
          if (spitter.pos.y > height() + 50) {
            destroy(spitter)
          }
        })

        return spitter
      }

      // === RUSHER ENEMY ===
      const RUSHER_CHARGE_SPEED = 600
      const RUSHER_TELEGRAPH = 0.7
      const RUSHER_STUN_TIME = 1.0
      const RUSHER_SIGHT_RANGE = 40  // vertical range to detect player

      function spawnRusher(x, y) {
        const rusher = add([
          sprite("rusher"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "rusher",
          {
            hp: 2,
            damage: 2,  // deals 2 damage
            state: "idle",  // idle, telegraph, charging, stunned
            stateTimer: 0,
            chargeDir: 1,
            originalX: x,
          }
        ])

        rusher.onUpdate(() => {
          if (!rusher.exists() || !rusher.scale || !player.exists()) return

          // state machine
          if (rusher.state === "idle") {
            // check if player is in horizontal line of sight
            const dy = Math.abs(player.pos.y - rusher.pos.y)
            if (dy < RUSHER_SIGHT_RANGE) {
              // start telegraph
              rusher.state = "telegraph"
              rusher.stateTimer = RUSHER_TELEGRAPH
              rusher.chargeDir = player.pos.x > rusher.pos.x ? 1 : -1
              rusher.scale.x = rusher.chargeDir
            }
          }
          else if (rusher.state === "telegraph") {
            // vibrate/shake during telegraph
            rusher.pos.x += Math.sin(time() * 50) * 2
            rusher.stateTimer -= dt()

            // flash red
            if (Math.floor(time() * 10) % 2 === 0) {
              rusher.opacity = 0.6
            } else {
              rusher.opacity = 1
            }

            if (rusher.stateTimer <= 0) {
              rusher.state = "charging"
              rusher.opacity = 1
            }
          }
          else if (rusher.state === "charging") {
            // charge at high speed
            rusher.pos.x += RUSHER_CHARGE_SPEED * rusher.chargeDir * dt()

            // stop if hit wall (screen edge or traveled too far)
            if (rusher.pos.x < 20 || rusher.pos.x > width() - 20 ||
                Math.abs(rusher.pos.x - rusher.originalX) > 500) {
              rusher.state = "stunned"
              rusher.stateTimer = RUSHER_STUN_TIME
              rusher.originalX = rusher.pos.x
              // impact shake
              shake(4)
            }
          }
          else if (rusher.state === "stunned") {
            // vulnerable, flashing
            rusher.opacity = 0.4 + Math.sin(time() * 15) * 0.3
            rusher.stateTimer -= dt()

            if (rusher.stateTimer <= 0) {
              rusher.state = "idle"
              rusher.opacity = 1
            }
          }
        })

        // fall death
        rusher.onUpdate(() => {
          if (!rusher.exists()) return
          if (rusher.pos.y > height() + 50) {
            destroy(rusher)
          }
        })

        return rusher
      }

      // === DRIFTER (floater, depth 5+) ===
      const DRIFTER_SPEED = 40  // slow drift toward player
      const DRIFTER_BOB_SPEED = 2  // sine wave frequency
      const DRIFTER_BOB_AMOUNT = 15  // sine wave amplitude

      function spawnDrifter(x, y) {
        const baseY = y
        const phaseOffset = Math.random() * Math.PI * 2  // random start phase

        const drifter = add([
          sprite("drifter"),
          pos(x, y),
          area({ scale: 0.7 }),  // smaller hitbox than visual
          anchor("center"),
          scale(1),
          opacity(0.9),
          z(Z.PLATFORMS + 1),
          "enemy",
          "drifter",
          {
            hp: 1,
            damage: 1,
            baseY: baseY,
          }
        ])

        drifter.onUpdate(() => {
          if (!drifter.exists() || !player.exists()) return

          // slowly drift toward player X
          const dx = player.pos.x - drifter.pos.x
          drifter.pos.x += Math.sign(dx) * DRIFTER_SPEED * dt()

          // bob up and down
          drifter.pos.y = drifter.baseY + Math.sin(time() * DRIFTER_BOB_SPEED + phaseOffset) * DRIFTER_BOB_AMOUNT

          // pulsing glow effect
          drifter.opacity = 0.7 + Math.sin(time() * 3 + phaseOffset) * 0.2

          // keep within bounds
          drifter.pos.x = Math.max(30, Math.min(width() - 30, drifter.pos.x))
        })

        return drifter
      }

      // === PILLAR (tank, depth 7+) ===
      const PILLAR_SPEED = 25  // very slow

      function spawnPillar(x, y) {
        const pillar = add([
          sprite("pillar"),
          pos(x, y),
          area(),
          body(),
          anchor("bot"),
          scale(1),
          z(Z.PLATFORMS + 1),
          "enemy",
          "pillar",
          {
            hp: 4,
            damage: 1,
          }
        ])

        pillar.onUpdate(() => {
          if (!pillar.exists() || !pillar.scale || !player.exists()) return

          // slow walk toward player
          const dx = player.pos.x - pillar.pos.x
          pillar.pos.x += Math.sign(dx) * PILLAR_SPEED * dt()
          pillar.scale.x = dx > 0 ? 1 : -1

          // slight sway for menace
          pillar.angle = Math.sin(time() * 2) * 2
        })

        // fall death
        pillar.onUpdate(() => {
          if (!pillar.exists()) return
          if (pillar.pos.y > height() + 50) {
            destroy(pillar)
          }
        })

        return pillar
      }

      // === HEALTH DROPS ===
      function spawnHealthDrop(p) {
        const drop = add([
          circle(8),
          pos(p.x, p.y),
          area(),
          anchor("center"),
          color(255, 50, 80),
          opacity(1),
          z(Z.PARTICLES + 5),
          "healthDrop",
        ])

        // floating animation
        const startY = p.y
        drop.onUpdate(() => {
          if (!drop.exists()) return
          drop.pos.y = startY + Math.sin(time() * 4) * 5
          drop.opacity = 0.7 + Math.sin(time() * 6) * 0.3
        })

        // despawn after 8 seconds
        wait(8, () => { if (drop.exists()) destroy(drop) })
      }

      // player picks up health
      player.onCollide("healthDrop", (drop) => {
        if (health < playerStats.maxHealth) {
          health = Math.min(health + 1, playerStats.maxHealth)
          healthText.text = "HEALTH: " + "♥".repeat(health)
          floatingText(vec2(player.pos.x, player.pos.y - 40), "+1", [50, 255, 100])
        }
        destroy(drop)
      })

      // === PLAYER DAMAGE FROM ENEMIES ===
      player.onCollide("enemy", (enemy) => {
        if (playerInvincible) return

        // check for enemy damage value (rusher deals 2)
        const dmg = enemy.damage || 1
        health -= dmg
        healthText.text = "HEALTH: " + "♥".repeat(Math.max(0, health))

        if (health <= 0) {
          go("gameover", depth)
          return
        }

        // i-frames
        playerInvincible = true
        invincibleTimer = 1.5

        // knockback
        const knockDir = player.pos.x > enemy.pos.x ? 1 : -1
        player.move(knockDir * 200, -150)

        // flash effect
        player.opacity = 0.5
        shake(5)
      })

      // i-frame timer
      onUpdate(() => {
        if (playerInvincible) {
          invincibleTimer -= dt()
          // flicker effect
          player.opacity = Math.sin(time() * 30) > 0 ? 1 : 0.3
          if (invincibleTimer <= 0) {
            playerInvincible = false
            player.opacity = 1
          }
        }
      })


      // === HUD ===
      add([
        rect(204, 18),
        pos(18, 18),
        color(hexToRgb(PALETTE.signalEmpty)),
        fixed(),
        z(Z.HUD),
      ])

      const signalBar = add([
        rect(200, 14),
        pos(20, 20),
        color(255, 0, 64),
        fixed(),
        z(Z.HUD + 1),
      ])

      const signalText = add([
        text("SIGNAL: 10/10", { size: 14 }),
        pos(20, 42),
        color(hexToRgb(PALETTE.text)),
        fixed(),
        z(Z.HUD),
      ])

      const healthText = add([
        text("HEALTH: " + "♥".repeat(health), { size: 16 }),
        pos(20, 62),
        color(255, 0, 64),
        fixed(),
        z(Z.HUD),
      ])

      const depthText = add([
        text("Depth: 1", { size: 14 }),
        pos(width() - 20, 20),
        anchor("topright"),
        color(hexToRgb(PALETTE.textDim)),
        fixed(),
        z(Z.HUD),
      ])

      // === EXIT ZONE (right side of screen) ===
      const exitZone = add([
        rect(30, height()),
        pos(width() - 30, 0),
        area(),
        opacity(0),
        "exit",
      ])

      // visual indicator for exit
      const exitGlow = add([
        rect(4, height() - 100),
        pos(width() - 10, 50),
        color(255, 0, 64),
        opacity(0.3),
        z(Z.PLATFORMS - 1),
      ])
      exitGlow.onUpdate(() => {
        exitGlow.opacity = 0.2 + Math.sin(time() * 3) * 0.15
      })

      // === UPGRADE ROOM ===
      function generateUpgradeRoom() {
        // clear everything
        get("platform").forEach(destroy)
        get("enemy").forEach(destroy)
        get("projectile").forEach(destroy)
        get("upgradeUI").forEach(destroy)

        inUpgradeRoom = true

        // simple safe room - just one central platform
        addOneWayPlatform("platform-lg", 300, 400)

        // show upgrade choices after brief delay
        wait(0.3, () => showUpgradeChoice())
      }

      function showUpgradeChoice() {
        // pick 2 random upgrades that haven't been applied
        const available = UPGRADES.filter(u => !appliedUpgrades.includes(u.id))
        if (available.length < 2) return  // no more upgrades

        const shuffled = available.sort(() => Math.random() - 0.5)
        const choices = shuffled.slice(0, 2)

        // title
        add([
          text("UPGRADE", { size: 32 }),
          pos(width() / 2, 100),
          anchor("center"),
          color(255, 0, 64),
          z(Z.HUD + 10),
          "upgradeUI",
        ])

        // create upgrade option boxes
        choices.forEach((upgrade, i) => {
          const boxX = width() / 2 - 150 + i * 300
          const boxY = 280

          // box background
          const box = add([
            rect(200, 140, { radius: 8 }),
            pos(boxX, boxY),
            anchor("center"),
            color(30, 30, 40),
            outline(2, { color: rgb(100, 100, 120) }),
            area(),
            z(Z.HUD + 10),
            "upgradeUI",
            "upgradeBox",
            { upgradeData: upgrade, selected: false },
          ])

          // upgrade name
          add([
            text(upgrade.name, { size: 20 }),
            pos(boxX, boxY - 35),
            anchor("center"),
            color(255, 255, 255),
            z(Z.HUD + 11),
            "upgradeUI",
          ])

          // upgrade description
          add([
            text(upgrade.desc, { size: 14 }),
            pos(boxX, boxY + 5),
            anchor("center"),
            color(180, 180, 180),
            z(Z.HUD + 11),
            "upgradeUI",
          ])

          // key hint
          add([
            text(`Press ${i + 1}`, { size: 18 }),
            pos(boxX, boxY + 45),
            anchor("center"),
            color(255, 0, 64),
            z(Z.HUD + 11),
            "upgradeUI",
          ])
        })

        // handle keyboard selection
        const key1 = onKeyPress("1", () => {
          selectUpgrade(choices[0])
          key1.cancel()
          key2.cancel()
        })
        const key2 = onKeyPress("2", () => {
          selectUpgrade(choices[1])
          key1.cancel()
          key2.cancel()
        })
      }

      function selectUpgrade(upgrade) {
        // apply the upgrade
        upgrade.apply()
        appliedUpgrades.push(upgrade.id)

        // flash effect
        get("upgradeUI").forEach(destroy)

        // show confirmation
        const confirmText = add([
          text(`${upgrade.name}!`, { size: 28 }),
          pos(width() / 2, 200),
          anchor("center"),
          color(0, 255, 128),
          opacity(1),
          z(Z.HUD + 10),
          "upgradeUI",
        ])

        // particles
        for (let i = 0; i < 20; i++) {
          add([
            circle(rand(3, 6)),
            pos(width() / 2 + rand(-100, 100), 200 + rand(-30, 30)),
            color(0, 255, 128),
            opacity(1),
            move(rand(0, 360), rand(50, 150)),
            lifespan(0.5, { fade: 0.3 }),
            z(Z.PARTICLES),
          ])
        }

        // clear upgrade room flag and show exit hint
        wait(0.8, () => {
          destroy(confirmText)
          inUpgradeRoom = false

          add([
            text("→ Continue", { size: 18 }),
            pos(width() - 80, height() / 2),
            anchor("center"),
            color(255, 255, 255),
            opacity(0.7),
            z(Z.HUD + 5),
            "upgradeUI",
          ])
        })
      }

      // === ROOM TRANSITION ===
      function nextRoom() {
        if (transitioning) return
        transitioning = true

        // brief flash
        const flash = add([
          rect(width(), height()),
          pos(0, 0),
          color(0, 0, 0),
          opacity(0),
          z(Z.HUD + 50),
        ])

        // fade to black
        tween(flash.opacity, 1, 0.2, (v) => flash.opacity = v, easings.linear).then(() => {
          // increment depth
          depth++
          depthText.text = `Depth: ${depth}`

          // reset player position
          player.pos = vec2(80, 400)
          facingDir = 1
          player.scale.x = 1

          // check for upgrade room (every 5 depths)
          if (depth > 0 && depth % 5 === 0) {
            generateUpgradeRoom()
          } else {
            generateRoom()
          }

          // fade back in
          tween(flash.opacity, 0, 0.2, (v) => flash.opacity = v, easings.linear).then(() => {
            destroy(flash)
            transitioning = false
          })
        })
      }

      // trigger transition when player enters exit zone
      player.onCollide("exit", () => {
        // block exit if in upgrade room and hasn't selected yet
        if (inUpgradeRoom) return
        nextRoom()
      })

      const sisterSignal = add([
        circle(8),
        pos(width() - 40, 50),
        color(255, 0, 64),
        opacity(1),
        anchor("center"),
        fixed(),
        z(Z.HUD),
      ])

      add([
        text("Arrow keys: Move | Space: Jump | Shift: Dash | X: Slash | R: Restart", { size: 12 }),
        pos(width()/2, height() - 15),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
        fixed(),
        z(Z.HUD),
      ])

      function updateHUD() {
        signalBar.width = (signal / playerStats.maxSignal) * 200
        signalText.text = `SIGNAL: ${Math.floor(signal)}/${playerStats.maxSignal}`
        if (signal < 3) {
          signalBar.opacity = 0.5 + Math.sin(time() * 10) * 0.5
        } else {
          signalBar.opacity = 1
        }
        const hp = Math.max(0, health)
        const maxHp = playerStats.maxHealth
        healthText.text = "HEALTH: " + "♥".repeat(hp) + "♡".repeat(maxHp - hp)
      }

      // === HYBRID GRAVITY ===
      player.onUpdate(() => {
        if (player.vel && player.vel.y < 0) {
          setGravity(GRAVITY_RISE)
        } else {
          setGravity(GRAVITY_FALL)
        }
        if (player.vel && player.vel.y > MAX_FALL_SPEED) {
          player.vel.y = MAX_FALL_SPEED
        }
      })

      // === MOVEMENT & ANIMATION ===
      onUpdate(() => {
        if (isDashing) return

        lastMoveDir = 0
        let isMoving = false

        if (isKeyDown("left") || isKeyDown("a")) {
          player.move(-playerStats.moveSpeed, 0)
          facingDir = -1
          lastMoveDir = -1
          isMoving = true
        }
        if (isKeyDown("right") || isKeyDown("d")) {
          player.move(playerStats.moveSpeed, 0)
          facingDir = 1
          lastMoveDir = 1
          isMoving = true
        }

        // update facing
        player.scale.x = facingDir
        swordArm.scale.x = facingDir

        // signal regen/drain
        if (lastMoveDir === 1) {
          signal = Math.min(playerStats.maxSignal, signal + SIGNAL_REGEN_RIGHT * playerStats.signalRegen * dt())
        } else if (lastMoveDir === -1) {
          signal = Math.max(0, signal - SIGNAL_DRAIN_LEFT * dt())
        } else {
          signal = Math.max(0, signal - SIGNAL_DRAIN_STILL * dt())
        }

        updateHUD()
      })

      // === JUMP ===
      onKeyPress("space", () => {
        if (isDashing) return

        if (player.isGrounded()) {
          player.jump(JUMP_FORCE)
          player.hasJumped = false

          for (let i = 0; i < 5; i++) {
            add([
              circle(rand(2, 4)),
              pos(player.pos.x + rand(-10, 10), player.pos.y + 25),
              color(150, 150, 160),
              opacity(0.5),
              move(rand(60, 120), rand(30, 60)),
              lifespan(0.3, { fade: 0.2 }),
              z(Z.PARTICLES),
            ])
          }
        } else if (player.canDoubleJump && !player.hasJumped) {
          player.jump(JUMP_FORCE * 0.85)
          player.hasJumped = true
          signal = Math.max(0, signal - 1)
        }
      })

      onKeyDown("space", () => {
        if (player.vel && player.vel.y < 0) {
          setGravity(GRAVITY_RISE * 0.8)
        }
      })

      // === DASH ===
      onKeyPress("shift", () => {
        if (isDashing || dashCooldown > 0 || signal < DASH_COST) return

        isDashing = true
        dashTimer = DASH_DURATION
        dashDir = facingDir
        iFrames = DASH_DURATION + 0.05
        signal -= DASH_COST

        player.scale.x = facingDir * 1.5
        player.scale.y = 0.7

        spawnAfterimage(player)
      })

      onUpdate(() => {
        if (isDashing) {
          const dashSpeed = playerStats.dashDistance / DASH_DURATION
          player.move(dashSpeed * dashDir, 0)
          dashTimer -= dt()

          if (Math.random() < 0.5) spawnAfterimage(player)

          if (dashTimer <= 0) {
            isDashing = false
            dashCooldown = 0.2
            player.scale = vec2(facingDir, 1)
          }
        }

        if (dashCooldown > 0) dashCooldown -= dt()
        if (iFrames > 0) iFrames -= dt()
      })

      // === SLASH ===
      function performSlash() {
        if (isSlashing || slashCooldown > 0) return
        if (signal < SLASH_COST) {
          floatingText(vec2(player.pos.x, player.pos.y - 32), "NO SIGNAL", [255, 100, 100])
          return
        }

        isSlashing = true
        slashCooldown = SLASH_DURATION + 0.1
        signal -= SLASH_COST

        // show sword blade - positioned at chest level (bot anchor, so y - 40)
        swordArm.opacity = 1
        swordArm.scale = vec2(facingDir * 1.5, 1.5)
        swordArm.pos = vec2(player.pos.x + facingDir * 10, player.pos.y - 40)
        swordArm.angle = -70

        // animate sword swing
        let slashProgress = 0
        const slashUpdate = swordArm.onUpdate(() => {
          slashProgress += dt() / SLASH_DURATION
          swordArm.angle = -70 + slashProgress * 120
          swordArm.pos = vec2(
            player.pos.x + facingDir * 10,
            player.pos.y - 40 + slashProgress * 15
          )
          swordArm.scale = vec2(facingDir * 1.5, 1.5)
          if (slashProgress >= 1) {
            slashUpdate.cancel()
          }
        })

        // slash arc effect
        const slashArc = add([
          sprite("slash-arc"),
          pos(player.pos.x + facingDir * 40, player.pos.y - 32),
          anchor("center"),
          scale(facingDir * 1.2, 1.2),
          opacity(1),
          z(Z.SLASH),
        ])

        // manually check and damage enemies in slash range
        const slashX = player.pos.x + facingDir * 40
        const slashY = player.pos.y - 20
        get("enemy").forEach((enemy) => {
          if (!enemy.exists()) return
          const dx = Math.abs(enemy.pos.x - slashX)
          const dy = Math.abs(enemy.pos.y - slashY)
          // hit enemies within range (horizontal: 60px, vertical: 50px)
          if (dx < 60 && dy < 50) {
            enemy.hp = (enemy.hp || 1) - playerStats.slashDamage
            shake(3)
            // flash white on hit
            enemy.color = rgb(255, 255, 255)
            wait(0.1, () => { if (enemy.exists()) enemy.color = rgb(255, 255, 255) })

            if (enemy.hp <= 0) {
              spawnStaticBurst(enemy.pos)
              // chance to drop health
              if (Math.random() < HEALTH_DROP_CHANCE) {
                spawnHealthDrop(enemy.pos)
              }
              destroy(enemy)
            }
          }
        })

        // slash deflects projectiles
        get("projectile").forEach((proj) => {
          if (!proj.exists()) return
          const dx = Math.abs(proj.pos.x - slashX)
          const dy = Math.abs(proj.pos.y - slashY)
          if (dx < 60 && dy < 50) {
            // deflect spark effect
            for (let i = 0; i < 5; i++) {
              add([
                circle(rand(2, 4)),
                pos(proj.pos),
                color(255, 200, 100),
                opacity(1),
                move(rand(0, 360), rand(80, 150)),
                lifespan(0.15, { fade: 0.1 }),
                z(Z.PARTICLES),
              ])
            }
            destroy(proj)
          }
        })

        // animate arc fade
        slashArc.onUpdate(() => {
          slashArc.opacity -= dt() * 5
        })

        slashBurst(vec2(player.pos.x, player.pos.y - 32), facingDir)
        shake(5)

        wait(SLASH_DURATION, () => {
          destroy(slashArc)
          swordArm.opacity = 0
          swordArm.angle = 0
          isSlashing = false
        })

        wait(SLASH_DURATION + 0.1, () => {
          slashCooldown = 0
        })
      }

      onKeyPress("x", performSlash)
      onKeyPress("j", performSlash)

      // === AURA PARTICLES & BREATHING ===
      onUpdate(() => {
        auraTimer -= dt()
        if (auraTimer <= 0 && !isDashing) {
          spawnAuraParticle(vec2(player.pos.x, player.pos.y - 32))
          auraTimer = 0.15
        }

        if (!isDashing && !isSlashing) {
          const pulse = 1 + Math.sin(time() * 1.5) * 0.03
          player.scale.x = facingDir * pulse
          player.scale.y = pulse
        }
      })

      // === SISTER SIGNAL PULSE ===
      sisterSignal.onUpdate(() => {
        const pulse = 0.4 + Math.sin(time() * 1.5) * 0.6
        sisterSignal.opacity = pulse
        sisterSignal.scale = vec2(1 + Math.sin(time() * 1.5) * 0.3)
      })

      // === FALL DEATH ===
      player.onUpdate(() => {
        if (player.pos.y > height() + 100) {
          go("gameover", depth)
        }
      })

      onKeyPress("r", () => go("game"))
      onKeyPress("escape", () => go("menu"))
    })

    // ============================================
    // GAME OVER SCENE
    // ============================================
    scene("gameover", (depth) => {
      add([sprite("bg"), pos(0, 0), z(Z.BG)])

      add([
        text("SIGNAL LOST", { size: 48 }),
        pos(center().x, 150),
        anchor("center"),
        color(255, 0, 64),
      ])

      add([
        text(`Depth reached: ${depth}`, { size: 24 }),
        pos(center().x, 250),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])

      add([
        text("The Static consumes all.", { size: 16 }),
        pos(center().x, 320),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      add([
        text("Press R to try again", { size: 20 }),
        pos(center().x, 420),
        anchor("center"),
        color(hexToRgb(PALETTE.text)),
      ])

      add([
        text("Press ESC for menu", { size: 14 }),
        pos(center().x, 460),
        anchor("center"),
        color(hexToRgb(PALETTE.textDim)),
      ])

      onKeyPress("r", () => go("game"))
      onKeyPress("escape", () => go("menu"))
    })

    go("menu")
  </script>
</body>
</html>
